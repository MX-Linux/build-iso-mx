#!/bin/bash

#==============================================================================
# build-iso: Build antiX liveCD/USB isos from scratch using debootstrap.
#
# Copyright 2012 -- 2019
#     BitJam and anticapitalista for antiX <antiX@operamail.com>
#==============================================================================

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

VERSION="1.99.09"
VERSION_DATE="March 24, 2023"

ME=${0##*/}

UPDATE_SKIP_PART="2-10,14-17,19"
ISO_SKIP_STAGE="2-5,7"

unset ARCH

usage() {
    cat << Usage
Usage: $ME [options] [N]

Build an antiX liveCD/USB iso from scratch using debootstrap.

Options:
    -a --auto           Don't prompt before entering each stage
    -A --AUTO           ... and also clear out most files when done.
    -c --chroot         Enter the chroot environment if it is available
    -C --COLOR=         Color mode: high|low|off. Default is high.
    -d --delete         Delete squashfs dir and stage-?.out files when done
                        without prompting
    -D --DELETE         Also delete entire work directory without prompting
    -e --error-ask      Ask before exiting due to stderr output messages
    -f --fast           Mount chroot directory as tmpfs for speed
    -F --FAST-UMOUNT    List and optionally umount all our tmpfs mounts
    -h --help           Show this help
    -i --iso-only       Only build an iso. Don't create a squashfs file
    -I --INTERACTIVE    Let Debian ask config questions inside the chroot
    -j --jbb            Suppress voluminous output
    -m --manual         Enter chroot if the automatic chroot stage fails
    -n --no-error-check Don't do error checking on stderr output
    -N --NO-ERROR-LOG   Also, don't log or highlight errors on stderr
    -p --pretend        Show what would be done next but do nothing
    -q --quiet          Ask fewer questions (and print less in --pretend mode)
    -r --reset          Update all default variables in stage 0
    -s --stats          Display the number of packages that would be installed
    -S --SAVE           Save the squashfs directory in the cache
    -u --update         Skip most parts in chroot stage preceding add and remove
    -U --UPDATE         Merge add.list and remove.list into the other lists
    -V --VERBOSE        Print even more than we already do
    -v --version        Print version info and exit
    --lz4               Override default compression scheme with lz4
    --user-default      Specify a defaults file, must be present in Input folder
    --zstd              Override default compression scheme with zstd
    --show-stages       Show the stages of processing
    --show-parts        Show parts of stage-$chroot_stage and how to control them
    -0 -- -8            Start over from stage N.

Short options stack: -up0 == -u -p -0 == --update --pretend -0

Optional argument:
    N                 Start over from stage N (same as -N).

Usage
    exit 0
}

# Output from start_main() does not get vlogged
main() {
    unset UMOUNT_ERRORS
    MAIN_T=$(date +%s)

    local firefox_prefs="/etc/skel/.mozilla/firefox/*/prefs.js"

    local all_stages="0 1 2 3 4 5 6 7 8 9"

    local chroot_stage=4

    local stage output_file
    local manual_mode pretend_mode auto_mode chroot_mode delete_mode delete_all
    local quiet_mode start_from reset_mode iso_only full_auto update_mode UPDATE_mode
    local show_parts show_stages interactive color_mode verbose_mode stats_mode
    local no_log_errors no_check_errors disable_errors do_fast check_tmpfs
    local save_mode jbb_mode

    local script_dir
    script_dir=$(dirname $(readlink -f $0))
    local template=$script_dir/Template
    local tools=$script_dir/Tools
    local output_dir=$script_dir/Output
    local input_dir=$script_dir/Input
    local remaster_dir
    remaster_dir=$(readlink -f $script_dir/Remaster)
    local iso_file_dir=$remaster_dir/iso-files
    local deb_cache_dir=$remaster_dir/deb-cache/archives
    local manual_selections=manual-selections
    local exit_file=$output_dir/MUST-EXIT
    local sign_off_file=$output_dir/SIGN-OFF

    local first_time_file=$input_dir/first-time
    local did_stage_file=$output_dir/did-stage
    local log_file=$output_dir/$ME.log
    local err_file=$output_dir/$ME.err
    local make_xinitrc=/usr/share/antiX/lib/make-xinitrc

    local live_files_list=$input_dir/live-files.list
    local strict_regex_file=$input_dir/strict-exceptions.regex
    local lax_regex_file=$input_dir/lax-errors.regex
    local regex_files="$lax_regex_file $strict_regex_file"
    local theme_dir=$script_dir/Themes
    local root_path="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/opt/bin"

    local part_env="ASK_PART EXIT_PART RUN_PART SHELL_PART SKIP_PART TEST_PART"
    local stage_env="ASK_STAGE EXIT_STAGE SKIP_STAGE"

    local build_dir="/Build"
    local partial_name="PARTIAL"
    local partial_file=$build_dir/$partial_name
    local seed_fname="random-seed"
    local user_defaults user_default_file apt_yes
    local initrd_encrypt

    local short_stack="aAcCdDefFhiIjmnNpqrsuUvV0-8"

    local arg val ARGS
    ARGS="$*"

    while [[ $# -gt 0 && $1 =~ ^- ]]; do
        arg=${1#-}; shift

        # Unstack single-letter options
        case $arg in
            [$short_stack][$short_stack]*)
                if echo "$arg" | grep -q "^[$short_stack]\+$"; then
                    set -- $(echo $arg | sed -r 's/([a-zA-Z])/ -\1 /g') "$@"
                    continue
                fi;;
        esac

        # Deal with all options that take a parameter
        case $arg in
          -color|C) [[ $# -lt 1 ]] && fatal "Expected a parameter after: $(pqw -$arg)"
                    val=$1
                    [[ $val =~ ^- ]] \
                        && fatal "Suspicious argument after -$arg: $(pqw $val)"

                    shift         ;;
    -user-default)  [ $# -lt 1 ] && fatal "Expected a parameter after: $(pqw -$arg)"
                    val=$1
                    user_defaults="$input_dir/$val"
                    [ ! -e "$user_defaults" ] \
                        && fatal "Default file not found -$arg: $(pqw $val)"

                    shift         ;;
              *=*)  val=${arg#*=} ;;
                *)  val="???"     ;;
        esac

        case $arg in
            -auto|a)      auto_mode=true ; apt_yes="-y"         ;;
            -AUTO|A)      auto_mode=true ; full_auto=true ; apt_yes="-y" ;;
          -chroot|c)    chroot_mode=true                        ;;
       -color=*|C=*)     color_mode=$val                        ;;
           -COLOR|C)     color_mode=$val                        ;;
          -delete|d)    delete_mode=true                        ;;
          -DELETE|D)    delete_mode=true ; delete_all=true      ;;
       -error-ask|e)     ask_errors=true                        ;;
            -fast|f)        do_fast=true                        ;;
     -FAST-UMOUNT|F)    check_tmpfs=true                        ;;
            -help|h)   usage                                    ;;
        -iso-only|i)       iso_only=true                        ;;
     -INTERACTIVE|I)    interactive=true                        ;;
             -jbb|j)       jbb_mode=true                        ;;
          -manual|m)    manual_mode=true                        ;;
  -no-error-check|n) disable_errors=true                        ;;
    -NO-ERROR-LOG|N)  no_log_errors=true ; disable_errors=true  ;;
         -pretend|p)   pretend_mode=true                        ;;
           -quiet|q)     quiet_mode=true                        ;;
           -reset|r)     reset_mode=true                        ;;
           -stats|s)     stats_mode=true                        ;;
            -SAVE|S)      save_mode=true                        ;;
        -show-parts)     show_parts=true                        ;;
       -show-stages)    show_stages=true                        ;;
          -update|u)    update_mode=true                        ;;
          -UPDATE|U)    UPDATE_mode=true                        ;;
      -user-default) user_default_file=true                     ;;
         -VERBOSE|V)   verbose_mode=true                        ;;
               -lz4)   lz4_override=true                        ;;
              -zstd)  zstd_override=true                        ;;

              [0-8]) [[ $start_from ]] && fatal "Can only set starting stage once"
                     start_from=$arg ;;

         -version|v) echo "$ME version $VERSION ($VERSION_DATE)"; exit ;;
                  *) fatal "Unknown parameter -$arg" ;;
        esac
    done

    is_antiX && apt_yes=

    if [[ $# -eq 1  && -z $start_from ]]; then
        arg=$1; shift
        case $arg in
            [0-8])  start_from=$arg ;;
                *)  fatal "Bad stage argument: $arg. Must be [0-8]."
        esac
    fi

    if [[ -n $update_mode ]]; then
        : ${start_from:=$((chroot_stage - 1))}
        SKIP_PART="$SKIP_PART${SKIP_PART:+,}$UPDATE_SKIP_PART"
    fi

    [[ -n $reset_mode ]] && : ${start_from:=0}
    [[ -n $iso_only   ]] && SKIP_STAGE="$SKIP_STAGE${SKIP_STAGE:+,}$ISO_SKIP_STAGE"

    case $color_mode in
     high|hi|"") color_mode="high" ;;
         low|lo) color_mode="low"  ;;
            off)                   ;;
              *) fatal "Bad --color operand: $color_mode" ;;
    esac

    local black blue green cyan red purple brown lt_gray dk_gray lt_blue
    local lt_green lt_cyan lt_red magenta yellow white rev_red nc
    local  text_co       bold_co   err_co
    local   num_co     prompt_co  time_co
    local  high_co

    if [[ $color_mode != "off" ]]; then
          black="\x1B[0;30m";     blue="\x1B[0;34m";      green="\x1B[0;32m";
           cyan="\x1B[0;36m";      red="\x1B[0;31m";     purple="\x1B[0;35m";
          brown="\x1B[0;33m";  lt_gray="\x1B[0;37m";    dk_gray="\x1B[1;30m";
        lt_blue="\x1B[1;34m"; lt_green="\x1B[1;32m";    lt_cyan="\x1B[1;36m";
         lt_red="\x1B[1;31m";  magenta="\x1B[1;35m";     yellow="\x1B[1;33m";
          white="\x1B[1;37m";  rev_red="\x1B[0;7;31m";       nc="\x1B[0m";
    fi

    case $color_mode in
        high) text_co=$lt_cyan;    bold_co=$yellow;     err_co=$lt_red;
               num_co=$magenta;  prompt_co=$lt_green;  time_co=$cyan;
              high_co=$white; ;;

         low) text_co=$nc;         bold_co=$lt_blue;    err_co=$red;
               num_co=$purple;   prompt_co=$green;     time_co=$cyan;
              high_co=$cyan; ;;
    esac

    [[ -n $pretend_mode ]] || SIGN_OFF="${bold_co}Quit$text_co $ME$nc"

    local pretty_fmt="%15s: $text_co%s$nc\n"

    [[ $# -gt 0 ]]           && fatal "Extra command line parameters: $(pqw $@)"
    [[ -z $script_dir ]]     && fatal "No script_dir!"
    [[ $script_dir = "/" ]]  && fatal "script_dir can't be root dir!"
    grep -v -P '="[^"]+"(\s+)?$' -r Template/COMMON/initrd/live/locale/xlat && fatal "Translation problems in xlat file"

    [[ -n $show_stages ]] && show_stages
    [[ -n $show_parts  ]] && show_parts

    SUDO=sudo
    [[ $UID -eq 0 ]] && SUDO=

    [[ -n $show_parts || -n $show_stages ]] && exit

    local normal_defaults="$input_dir/defaults $input_dir/defaults-local"
    local all_defaults="$input_dir/defaults-system $normal_defaults"

    if [[ -n $user_default_file ]]; then
        local normal_defaults="$user_defaults $input_dir/defaults-local"
        local all_defaults="$input_dir/defaults-system $normal_defaults"
    fi

    load_defaults

    trap on_exit       EXIT
    trap "echo; exit"  INT

    if [[ -n $pretend_mode || -n $chroot_mode || -n $stats_mode ]]; then
        log_file=/dev/null
    else
        mkdir -p $(dirname $log_file)
    fi

    if [[ -n $check_tmpfs ]]; then
        check_all_tmpfs && exit
        vexit "No tmpfs mounts were found"
    fi

    [[ "$script_dir" == "$build_dir" ]] && no_log_errors=true

    {
        printf "\n$bold_co%63s$nc\n" "" | sed 's/ /-/g'
        echo -e "$ME $ARGS"
        echo -e "  version: $VERSION ($VERSION_DATE)"
        echo -e "  started: $(date)"
        echo -e "directory: $script_dir\n"
    } >> $log_file

    # Always start out with a clean slate
    rm -f $exit_file $sign_off_file

    update_template_file basic-applications.list basic-package.list
    update_template_file pesky-packages.list     pesky-package.list

    [[ -n $update_mode ]] && say "update mode: skipping parts $(pq $SKIP_PART)"

    expand_parts $part_env $stage_env

    # Clear out the did-stage file
    : > $did_stage_file
    # We only advance to the next stage if the previous stages all completed and wrote
    # stage-N.out output files. These files are also used for passing information on
    # from one stage to the next.
    while true; do

        # Read previous output files and set the stage
        for stage in $all_stages; do
            output_file=$output_dir/stage-$stage.out
            [[ -r $output_file ]] || break
            [[ -n $start_from ]] && [[ $stage -eq $start_from ]] && break
            source $output_file
        done

        # Variables derived from output files
        local full_distro_name=$DISTRO_NAME-${DISTRO_VERSION}_$ISO_ARCH
        [[ $DISTRO_NAME = antiX ]] && full_distro_name=$full_distro_name-$ISO_FLAV

        local fancy_name="$full_distro_name $CODE_NAME $RELEASE_DATE"
        local work_name=$DISTRO_NAME-${DISTRO_VERSION}-$ISO_ARCH-$DEBIAN_RELEASE
        [[ $DISTRO_NAME = antiX ]] && work_name=$work_name-$ISO_FLAV
        local work_dir=$remaster_dir/work/$work_name
        local iso_dir=$work_dir/iso
        local sqfs_dir=$work_dir/squashfs
        local sqfs_output_dir=$sqfs_dir$build_dir/Output
        local sqfs_input_dir=$sqfs_dir$build_dir/Input
        local boot_menu_dir=$sqfs_dir/usr/local/share/boot-menus

        local initrd_dir=$work_dir/initrd
        local manual_selections_template=$template/COMMON/$manual_selections

        local chroot_cache_opts="chroot $work_name $sqfs_dir"
        local deboot_cache_opts="debootstrap $ARCH-$DEBIAN_RELEASE $sqfs_dir"

        # Do weird modes here after variables are set
        [[ -n $chroot_mode ]] && do_chroot && exit

        if [[ -n $start_from ]]; then
            [[ $stage -lt $start_from ]] \
                && fatal "Only at stage $(pqnw $stage). Can't start from stage $(pqnw $start_from)."

            clear_outputs $start_from "$pretend_mode" "$delete_mode" || exit
            start_from=
        fi
        [[ -n $save_mode    ]] && do_save    && exit
        [[ -n $pretend_mode ]] && do_pretend && exit
        [[ -n $stats_mode   ]] && do_stats   && exit
        [[ -n $UPDATE_mode  ]] && update_add_remove_lists && exit

        [[ "$script_dir" == "$build_dir" && "$stage" != "$chroot_stage" ]] \
            && fatal "In chroot environment but stage is $(pqw $stage)"

        # Set window title (but only in normal modes)
        echo -ne "\e]0;$ME stage:$stage $full_distro_name\a"
        DID_WINDOW_TITLE=true

        if has_word SKIP_STAGE $stage; then
            say "Skipping stage $(pqn $stage)"
            leave_stage notime
            continue
        fi

        # We read in these files every time because they might have been
        # edited inside the stages and the changes don't propagate up to here
        if [[ -z $disable_errors ]]; then
            read_error_regexes
            check_errors_reset
            #say "ERROR_OFFSET=$ERROR_OFFSET"
        fi

        if [[ $stage -ne $chroot_stage && -z $no_log_errors ]]; then

            [[ -e $exit_file ]] && exit $(cat $exit_file)

            # The tee and sed only apply to stdrr. Stdout goes right through.
            # This highlights stderr output and stores it in a file which we
            # periodically scan with the check_errors_* routines
            main_case  7>&1 1>&2 2>&7 \
                | tee -a $err_file | sed -e "s/^/$red/" -e "s/$/$nc/"

            # The redirects above cause main_case() to launch in a subshell which
            # breaks the "exit" command. This fixes it by using my_exit() which
            # writes $exit_file before exiting
            [[ -e $exit_file ]] && exit $(cat $exit_file 2>/dev/null)

        else
            main_case
        fi

    done
}

main_case() {
    case $stage in
         0) do_stage_0   ;;
         1) do_stage_1   ;;
         2) do_stage_2   ;;
         3) do_stage_3   ;;
         4) do_stage_4   ;;
         5) do_stage_5   ;;
         6) do_stage_6   ;;
         7) do_stage_7   ;;
         8) do_stage_8   ;;
         9) do_stage_9   ;;
         *) fatal "Unknown stage: $stage"
    esac
}

#==============================================================================
# The Ten Stages of Processing
#==============================================================================
#------------------------------------------------------------------------------
# Stage 0 gathers all user input and prepares defaults and directories
#------------------------------------------------------------------------------
do_stage_0() {
    enter_stage 0 "!Gather inputs and set defaults"

    [[ -s $err_file && -z $no_log_errors ]]  \
        && YES_no "Clear error file $(pq $ME.err)" && : > $err_file

    if [[ -e $first_time_file ]]; then
        say    "The input file structure and layout have changed."
        say    "Your are encouraged to run in $(pq --reset) mode to verify input parameters."
        if YES_no "Enter $(pq --reset) mode"; then
            say "Entering $(pq --reset) mode."
            reset_mode=true
        else
            rm -f $first_time_file
        fi
    fi

    pick_prog MAKE_ISO $MAKE_ISO_PROGS
    pick_prog GZIP     $GZIP_PROGS

    require_programs chroot debootstrap isohybrid mksquashfs md5sum sudo tee zsync \
        pkill column expand strings iconv unbuffer

    mkdir -p $output_dir || my_exit

    # Give user a chance to set up directories the way they want
    if ! [[ -d $remaster_dir ]]; then
        cat << Remaster_Blurb

The "Remaster" directory does not exist. This is where *.iso files,
cache files, and intermediate storage will reside. Think gigabytes.

If you want it to be on a different device then exit now and create
a symlink called "Remaster".

Remaster_Blurb

        YES_no_loud "Shall I create a local \"Remaster\" directory for you" \
            || vexit "Need Remaster symlink or directory to continue"

        mkdir -p $script_dir/Remaster || my_exit
    fi

    local name
    for name in DISTRO_NAME DISTRO_VERSION CODE_NAME K_VERSION K_REVISION \
        NEW_HOSTNAME; do
        update_default $name
    done

    load_defaults

    # Fill in default value
    : ${RELEASE_DATE:=$(date +"%-e %B %Y")}

    choose "local mirror" LOCAL_MIRROR                       \
                us gr au be bg br ch cz de dk ee es "fi" fr  \
                gr hk hr hu ie is it jp kr nl no nz pl pt ro \
                ru se si sk tr tw ua uk us

    choose "Debian release" DEBIAN_RELEASE \
                stable testing unstable bullseye bookworm

    choose "which locales to enable" ENABLE_LOCALES  \
                "Default (about 60)"                 \
                "All (about 400)"                    \
                "Single (the one default locale)"

    choose "arch"     ARCH      i386 amd64
    choose "flavour"  ISO_FLAV  $(flavour_list) core-libre

    K_GNU=
    case $ISO_FLAV in
        *-libre) K_GNU=-gnu
                 FLAV=${ISO_FLAV%-libre} ;;
              *) FLAV=$ISO_FLAV ;;
    esac

    RESPIN_INHERIT=
    if is_distro_flav $FLAV; then
        ISO_RESPIN_OF=$FLAV
    else
        choose "flavour to base respin on" ISO_RESPIN_OF full base core

        if [[ -z $(ls $template/$FLAV) ]] \
            && YES_no "Fill \"$FLAV\" directory from $ISO_RESPIN_OF ?"; then
            cp $template/$ISO_RESPIN_OF/*.list $template/$FLAV/
            YES_no "Do you want to stop now to edit your new respin?" \
                && vexit "at user's request"
        fi
        RESPIN_INHERIT=$ISO_RESPIN_OF
    fi

    is_distro_flav $ISO_RESPIN_OF || fatal "Invalid flavour to base respin on: $ISO_RESPIN_OF"

    local distro_k_arch=686
    is_antiX && distro_k_arch=486
    case $ARCH in
         i386) K_ARCH=$distro_k_arch   ; ISO_ARCH=386  ;;
        amd64) K_ARCH=amd64            ; ISO_ARCH=x64  ;;
            *) error "Invalid ARCH $(pqw $ARCH). Expected $(pqw i386) or $(pqw amd64)". ;;
    esac

    K_NAME=$(echo $K_TEMPLATE | sed \
    -e "s/%V/$K_VERSION/"   \
    -e "s/%G/$K_GNU/"       \
    -e "s/%R/$K_REVISION/"  \
    -e "s/%A/$K_ARCH/"      \
    -e "s/%V/$K_VERSION/")

    local $HOST_ARCH
    case $(arch) in
        i386|i486|i686) HOST_ARCH=386 ;;
        x86_64)         HOST_ARCH=x64 ;;
        *) error "Cannot detect Host ARCH" ;;
    esac

    # Detect kernel if using wildcards
    # This won't work if host is running a different ARCH
    if [[ $K_NAME =~ \* ]]; then
        if [[ $ISO_ARCH == "$HOST_ARCH" ]]; then
            search_for_k_name || error "Not running on the same ARCH as the build, \
might want to avoid using wildcards for kernels, otherwise you won't be able to start the build at different steps."
        fi
    fi

    #$K_VERSION$K_GNU-antix.$K_REVISION-$K_ARCH-smp

    [[ -n $THEME ]] || select_theme

    check_theme_dir $THEME

    # repeated code
    remaster_dir=$(readlink -f $script_dir/Remaster)
    local full_distro_name=$DISTRO_NAME-${DISTRO_VERSION}_$ISO_ARCH
    [[ $DISTRO_NAME = antiX ]] && full_distro_name=$full_distro_name-$ISO_FLAV
    local iso_file=$full_distro_name.iso

    local dir
    for dir in $(flavour_list) COMMON base-AND-full; do
        mkdir -p $script_dir/Deb/$dir
    done

    local full_iso_file=$iso_file_dir/$iso_file
    if [[ -e $full_iso_file ]]; then
        say "The output file $(pq Remaster/iso-files/$iso_file) already exists!"
        say "If we continue then it will get over-written."
        YES_no "Continue anyway" || my_exit 0
    fi

    cat << Output > $output_file
ARCH="$ARCH"
DEBIAN_RELEASE="$DEBIAN_RELEASE"
FLAV="$FLAV"
GZIP="$GZIP"
ISO_ARCH="$ISO_ARCH"
ISO_FLAV="$ISO_FLAV"
K_NAME="$K_NAME"
MAKE_ISO="$MAKE_ISO"
RELEASE_DATE="$RELEASE_DATE"
RESPIN_INHERIT="$RESPIN_INHERIT"
THEME="$THEME"
ISO_RESPIN_OF="$ISO_RESPIN_OF"
Output

    say "Ready to begin creation of $(pq $iso_file)"
    pretty_output $((stage + 1)) >> $log_file

    [[ -e $first_time_file ]] && rm -f $first_time_file

    if [[ -z $quiet_mode ]]; then
        echo "With:"
        pretty_output $((stage + 1))
        echo
    fi
    do_one_stat
    printf "$pretty_fmt"  REMASTER_DIR  $remaster_dir
    printf "$pretty_fmt" "on device"    $(df $remaster_dir | tail -n1 | cut -f1 -d" ")
}

#------------------------------------------------------------------------------
# Stage 1 creates working directories and symlinks
#------------------------------------------------------------------------------
do_stage_1() {
    enter_stage 1 "Make directories and symlinks"

    convenience_link $work_dir   work
    convenience_link $sqfs_dir   sqfs
    convenience_link $iso_dir    iso
    convenience_link $initrd_dir initrd

    $SUDO chown root:root $sqfs_dir

    leave_stage notime
}

#------------------------------------------------------------------------------
# Stage 2 runs debootstrap, makes some small adjustmesnt to the fs and also
# handles caching what debootstrap created.
#------------------------------------------------------------------------------
do_stage_2() {
    enter_stage 2 "Run debootstrap"

    [[ $do_fast ]] && mount_tmpfs

    if test -d $sqfs_dir; then
        say "Clear out existing files ..."
        check_sqfs_dir
        # Convoluted to be safer against deleting entire filesystem
        $SUDO rm -rf $(dirname $sqfs_dir)/squashfs/*
    fi

    if restore_cache $chroot_cache_opts; then
        leave_stage
        return
    fi

    if ! restore_cache $deboot_cache_opts; then

        say "debootstrap for $(pq $ARCH $DEBIAN_RELEASE) from local mirror $(pq $LOCAL_MIRROR) ..."
        umount_chroot
        mount_deb_cache

        local args cnt exclude_list include_list keyring url
        args="--arch=$ARCH"
        exclude_list=$(gather_join exclude-debootstrap)
        include_list=$(gather_join include-debootstrap)
        cnt=$(echo "$exclude_list" | tr ',' '\n' | wc -l)
        psay $cnt "Exclude $(pqn %n) package%s"
        keyring="$template/$ISO_RESPIN_OF/keyring.gpg"
        [[ -n $exclude_list ]] && args="$args --exclude=$exclude_list"
        [[ -n $include_list ]] && args="$args --include=$include_list"
        [[ -r $keyring ]] && args="$args --keyring=$keyring"
        url="$(eval echo $MIRROR_URL_TEMPLATE)"

        check_errors_strict
        start_timer
        $SUDO debootstrap $args $DEBIAN_RELEASE $sqfs_dir $url
        end_timer "run debootstrap $ARCH $DEBIAN_RELEASE"
        check_errors_lax

        ##anticapitalista - remove systemd from 4 files in /etc
        if is_antiX; then
            say "removing systemd from 4 files"
            $SUDO sed -i '/^systemd/d' $sqfs_dir/etc/{group,gshadow,passwd,shadow}
            say "de-systemd complete"
        fi

        umount_chroot

        [[ -e $sqfs_dir/bin/bash ]] || error "debootstrap failed"
    fi

    report_size $sqfs_dir

    create_cache $deboot_cache_opts

    say "Customize live system for antiX"
    $SUDO rm -f  $sqfs_dir/etc/apt/sources.list
    copy_template_dir squashfs $sqfs_dir

    leave_stage
}

#------------------------------------------------------------------------------
# Stage 3 prepares for running the chroot command for either a Bash shell or
# for running stage 4 in the chroot. Much of this functionality is repeated
# when the --chroot option is used so we put most of the work in prep_chroot().
#------------------------------------------------------------------------------
do_stage_3() {
    enter_stage 3 "Prepare chroot"

    check_sqfs_dir

    # We want to run stage N+1 inside the chroot so we need to signal
    # that the current stage is done
    leave_stage notime

    # Save the PARTIAL file from destruction but don't be fooled by older copies
    rm -f $work_dir/$partial_name
    [[ -e $sqfs_dir$partial_file ]] && cp $sqfs_dir$partial_file $work_dir

    # Make sure we start over from scratch
    $SUDO rm -rf $sqfs_dir$build_dir

    prep_chroot

    # Put saved PARTIAL file back in the build directory
    [[ -e $work_dir/$partial_name ]] \
        && $SUDO mv $work_dir/$partial_name $sqfs_dir$partial_file

    # This stage must fail if the next stage fails
    rm $output_file

    # Get realtime log updates from the chroot
    (tail -n 0 -f $sqfs_output_dir/$ME.log >> $log_file) &
    export TAIL_PID_1=$!

    if [[ -z $no_log_errors ]]; then
        touch $err_file
        (tail -n 0 -f $err_file > $sqfs_output_dir/$ME.err) &
        export TAIL_PID_2=$!
    fi
    HOST_HOSTNAME=$(hostname)

    local args
    local next_output_file=$sqfs_output_dir/stage-$((stage + 1)).out

    [[ -n $interactive     ]] && args="--interactive"
    [[ -n $auto_mode       ]] && args="$args --auto"
    [[ -n $quiet_mode      ]] && args="$args --quiet"
    [[ -n $ask_errors      ]] && args="$args --error-ask"
    [[ -n $verbose_mode    ]] && args="$args --VERBOSE"
    [[ $color_mode != high ]] && args="$args --COLOR=$color_mode"
    [[ -n $disable_errors  ]] && args="$args --no-error-check"
    mountpoint -q $sqfs_dir   && args="$args --fast"

    check_errors_strict

    say "Run $(pq $ME) in chroot"
    $SUDO chroot $sqfs_dir $build_dir/$ME $args

    $SUDO hostname "$HOST_HOSTNAME"

    if [[ ! -e $next_output_file && -n $manual_mode ]]; then
        say "The buld inside the chroot failed"
        say  "======================================================="
        say  "You are in a chroot environment."
        say  "Use the command $(pq /Build/$ME $args)"
        say  "to continue building"
        say  "Use $(pq exit) or $(pq Ctrl-D) when done"
        say  "======================================================="
        $SUDO chroot $sqfs_dir /bin/bash -rcfile $build_dir/bashrc 2>&1
        say "Left chroot"
    fi

    check_errors_reset
    clear_pids
    kill_chroot_procs
    umount_chroot

    [[ -e $next_output_file ]] || fatal "Build inside chroot failed"

    local chroot_selections=$sqfs_dir$build_dir/$manual_selections
    if [[ -r $chroot_selections ]]; then
        say "Update $(pq $manual_selections) in Template"
        cp $chroot_selections $manual_selections_template
    fi

    local missing
    for missing in "$sqfs_dir$build_dir"/missing*; do
        [[ -r $missing ]] && cp $missing $work_dir
    done

    cp $sqfs_output_dir/package-list.out        $work_dir
    cp $sqfs_input_dir/strict-exceptions.regex  $input_dir
    cp $sqfs_input_dir/lax-errors.regex         $input_dir
    cp $next_output_file                        $output_dir

    leave_stage

    report_size $sqfs_dir
}

#-----------------------------------------------------------------------------
# Stage 4 is the heart of the program. It runs inside the chroot and does most
# of the tasks needed to convert a debootstrap system into antiX. Each part
# inside here can be controled with the ASK_PART, SKIP_PART, etc environment
# variables.
#------------------------------------------------------------------------------
do_stage_4() {
    enter_stage 4 "!Inside of chroot"
    _say_ "$num_co===============================================================$nc"

    #error-logchecking ASAP so we don't waste user's time
    [[ "$script_dir" == "$build_dir" ]] || fatal "We do not appear to be in a chroot environment"

    [[ -n $K_NAME ]] || error "No K_NAME specified"

    if ! [[ -r $manual_selections_template ]]; then
        say "No $(pq $manual_selections) file found. Forcing $(pq interactive) mode"
        interactive=true
    fi

    if [[ -n $interactive ]]; then
        say "Interactive mode $(pq enabled)"
        if [[ -r $manual_selections_template ]] && YES_no_loud "Load current defaults"; then
            say "Set defaults from $(pq $manual_selections) file"
            debconf-set-selections $manual_selections_template
        fi
    else
        say "interactive mode ${num_co}disabled"
        export DEBIAN_FRONTEND=noninteractive
        say "Set defaults from $(pq $manual_selections) file"
        debconf-set-selections $manual_selections_template
    fi

    # Doesn't seem to be needed, it just shows an error that /proc/mounts = /etc/mtab
    # say "Create $(pq /etc/mtab)"
    # grep -v rootfs /proc/mounts > /etc/mtab

    echo $$ > $build_dir/MY-PID

    say "prepend $(pq $build_dir/fake) to PATH"
    PATH=$build_dir/fake:$PATH

    # Read in the ASK_PART, SKIP_PART, etc values from outer program
    [[ -r $script_dir/ENV_IN ]] && source $script_dir/ENV_IN

    require_programs apt-get

    if [[ -s $partial_file ]]  \
        && do_part 0 "!Read PARTIAL file to skip parts done"; then
        local add_skip
        add_skip=$(join_lines $partial_file ",")
        say "have already processed these parts: $(pq $add_skip)"
        if YES_no "Skip these parts this time"; then
            SKIP_PART="$SKIP_PART${SKIP_PART:+,}$add_skip"
        else
            rm -f $partial_file
        fi
    else
        skip_part 0 "Read PARTIAL file to skip parts done"
    fi

    if ! is_antiX; then
        local early_deb
        if ls /*${ARCH}.deb >/dev/null 2>&1; then
            for early_deb in /*${ARCH}.deb; do
                [[ -f $early_deb ]] || continue
                say "Install arch deb package $(pq $early_deb)"
                apt-get install "$early_deb"; rm "$early_deb"
            done
        fi
        if ls /*all.deb >/dev/null 2>&1; then
            for early_deb in /*all.deb; do
                say "Install all deb package $(pq $early_deb)"
                apt-get install $early_deb; rm $early_deb
            done
        fi
    fi

    # for 64 bit set multiarch
    if [[ $ARCH = "amd64" ]] ; then
        say "Adding multiarch support"
        dpkg --add-architecture i386
    fi

    if do_part 1 "Update repos and do apt-get update"; then
        local list_dir=/etc/apt/sources.list.d
        # Remove non-free repos from -libre flavours
        [[ $ISO_FLAV =~ -libre$ ]] \
            && sed -i -e 's/\<contrib\>//g' -e 's/\<non-free\>//g' $list_dir/debian.list

        apt-get $APT_GET_OPTS update
        end_part_lax
    fi

    if [[ $K_NAME =~ \* ]] && do_part 2 "Search for complete kernel name"; then
        # Use apt-cache to get full kernel name if it contains a "*"
        search_for_k_name
        end_part_strict
    else
        skip_part 2 "Search for complete kernel name"
    fi

    : ${LOCALE:=en_US.UTF-8}

    if do_part 3 "!Define locales"; then
        case $ENABLE_LOCALES in
            [Aa]ll) say "Will build $(pq all) locales"
                    sed -i -r "s/^# ([a-z][a-z]([a-z]?_| ISO|\.UTF| UTF))/\1/" /etc/locale.gen;;

        [Dd]efault) say "Will build $(pq default) default locales" ;;

         [Ss]ingle) say "Will build $(pq "$LOCALE") locale"
                    local locale_re=${LOCALE//./\.}
                    sed -i -r -e "s/^([a-z])/# \1/" -e "s/^#\s+($locale_re)/\1/" /etc/locale.gen;;

                 *) error "Bad ENABLE_LOCALES: $ENABLE_LOCALES"
        esac

        local cnt
        cnt=$(grep -c '^[a-zA-Z]' /etc/locale.gen)
        psay $cnt "There %are now $(pqn %n) locale%s to generate"
        end_part_lax
    fi

    if gather_any basic-package \
        && do_part 4 "Install basic packages"; then
        install_packages basic-package basic
        end_part_lax
    else
        skip_part 4 "Install basic packages"
    fi

    if do_part 5 "Install kernel & headers"; then
        local kname=linux-image-$K_NAME
        ! is_antiX && kname=$kname$UNSIGNED
        apt-get $APT_GET_OPTS install linux-headers-$K_NAME $kname
        end_part_strict
    fi

    if do_part 6 "Update locales"; then
        : ${LOCALE:=en_US.UTF-8}
        say "Set default locale to $(pq $LOCALE)"
        update-locale LANG=$LOCALE
        end_part_lax
    fi

    if gather_any pesky-package \
        && do_part 7 "Install pesky packages"; then
        gather_say pesky-package "Install $(pqn %n) pesky package%s"
        for package in $(compile_pkg_list pesky-package exclude-chroot); do
            DEBIAN_FRONTEND=dialog apt-get install $apt_yes $package
        done
        end_part_lax
    else
        skip_part 7 "Install pesky packages"
    fi

    if gather_any package \
        && do_part 8 "Install antiX packages"; then
        install_packages package $FLAV
        end_part_lax

    else
        skip_part 8 "Install antiX packages"
    fi

    #say_in $high_co "$(list_newer_procs)"

    show_tmpfs_and_mem

    if do_part 9 "Run first apt-get -f $apt_yes install"; then
        apt-get update && apt-get $APT_GET_OPTS dist-upgrade
        apt-get -f install
        end_part_lax
    fi

    local debs cnt
    debs=$(ls $build_dir/Deb/*.deb 2>/dev/null)
    cnt=$(echo "$debs" | wc -w)
    if [[ $cnt -gt 0 ]] \
        && do_part 10 "Install latest antiX debs"; then
        psay $cnt "Install $(pqn %n) .deb package%s"

        for deb in $debs; do
            say "install $(pq ${deb##*/})"
            apt-get install $deb
        done
        end_part_lax
    else
        skip_part 10 "Install latest antiX debs"
    fi

    if gather_any remove \
        && do_part 11 "Remove some packages"; then
        gather_say remove "Remove $(pqn %n) package%s"
        apt-get purge $(gather remove) $apt_yes
        end_part_lax
    fi

    if gather_any add \
        && do_part 12 "Add some packages"; then
        install_packages add "additional"
        end_part_lax
    fi

    if gather_any reinstall \
        && do_part 13 "Reinstall some packages"; then
        install_packages reinstall Reinstall --reinstall
        end_part_lax

    else
        skip_part 13 "Reinstall some packages"
    fi

    if do_part 14 "!Update/configure X-related programs"; then

        if [[ -n $(which slim) && -e /etc/slim.conf ]]; then
            say "Enable demo as live user in slim.conf"
            sed -i -r '/default_user/ s/^#+//' /etc/slim.conf
        fi

        if [[ -n $X_TERM_EMULATOR && -x $X_TERM_EMULATOR ]]; then
            say "Set x-terminal-emulator to $(pq $X_TERM_EMULATOR)"
            update-alternatives --set x-terminal-emulator $X_TERM_EMULATOR
        else
            error "Missing or unknown x-term-emulator $(pqw $X_TERM_EMULATOR)"
        fi

    if [[ -e $CURSOR_ICON_THEME ]]; then
        say "Set cursor icon theme to $(pq $CURSOR_ICON_THEME)"
        if is_antiX; then
            local theme dir
            for theme in oxy-white oxy-black Breeze-Snow Breeze-Amber; do
                dir=/usr/share/icons/$theme
                test -d "$dir" || continue
                update-alternatives --install /usr/share/icons/default/index.theme x-cursor-theme "$dir"/index.theme 20
            done
        fi
        update-alternatives --set x-cursor-theme $CURSOR_ICON_THEME
    else
        error "Missing or unknown cursor icon theme $(pqw $CURSOR_ICON_THEME)"
    fi

    say "Reconfigure networking sym links"
        update-rc.d networking remove
        update-rc.d networking defaults
        say "Disable bootchart-done"
        update-rc.d "bootchart-done" remove
        end_part_strict
    fi

    local update_flash="update-flashplugin-nonfree"
    if which $update_flash 2>/dev/null && do_part 15 "Get Latest Flash"; then
        $update_flash

        #local flash_selector="flashplayer-selector.sh"
        #if [[ $ARCH = "i386" ]] && which $flash_selector 2>/dev/null; then
        #   say "Set old flash"
        #   $flash_selector
        #fi
        end_part_lax
    fi

    local udev_file="/etc/udev/rules.d/90-fstab-automount"
    if [[ -e $udev_file.live ]]; then
        say "Adding correct suffix to $udev_file.live"
        mv $udev_file.live $udev_file.rules
    fi

    if is_antiX; then
        #update icons cache files
        local update_icons="gtk-update-icon-cache"
        local icon_folder="/usr/share/icons"
        say "Updating icons cache"
        #$update_icons $icon_folder/elementaryXubuntu-dark
        $update_icons $icon_folder/Faenza
        $update_icons $icon_folder/papirus-antix
        #$update_icons $icon_folder/Faenza-Cupertino-mini
    else
        update-icon-caches /usr/share/icons/*
    fi

    if [[ -n $interactive ]] &&  do_part 16 "Manual configuration"; then

        say "Manual configuration"
        local save_cnt
        save_cnt=$(gather_cnt save-selections)
        psay $save_cnt "Save selections from $(pqn %n) package%s"
        local package package_re
        for package in $(gather save-selections); do
            package_re=${package_re:+$package_re\|}
            package_re=$package_re^$package
        done

        local reconfig_cnt
        reconfig_cnt=$(gather_cnt reconfigure)
        psay $reconfig_cnt "Reconfigure $(pqn %n) package%s"

        if [[ $reconfig_cnt -gt 0 ]] && YES_no "Are you ready"; then

            for package in $(gather reconfigure); do
                say "Manual configuration for $(pqn $package)"
                dpkg-reconfigure -f dialog $package
                package_re=${package_re:+$package_re\|}
                package_re=$package_re^$package
            done
        fi

        if [[ $save_cnt -gt 0 || $reconfig_cnt -gt 0 ]]; then
            YES_no "Save these new selections"                     \
                && debconf-get-selections                          \
                | grep -E "^$package_re" | grep -v "[[:space:]]$"  \
                | sort > $build_dir/$manual_selections
        fi
        end_part_lax
    else
        skip_part 16 "Manual configuration"
        _say_
        local reconfigure cnt
        reconfigure=$(cut -f1 $manual_selections_template | cut -d: -f1 | sort -u)
        cnt=$(echo "$reconfigure" | wc -w)
        psay $cnt "Automatic reconfiguration of $(pqn %n) package%s"
        for package in $reconfigure; do
            dpkg-reconfigure -f noninteractive $package
        done
        check_errors_lax
    fi

    if do_part 17 "!Update Timezone, hostname, and user accounts"; then
       if [[  -n $TIME_ZONE && -e /usr/share/zoneinfo/$TIME_ZONE ]]; then
            say "Set timezone and localtime to $(pq $TIME_ZONE)"
            echo $TIME_ZONE > /etc/timezone
            DEBIAN_FRONTEND=noninteractive dpkg-reconfigure -f noninteractive tzdata
            end_part_lax
        else
            error "Unknown time zone $(pqw $TIME_ZONE)"
        fi

        : ${NEW_HOSTNAME:=antix1}
        say "Set hostname to $(pq $NEW_HOSTNAME)"
        echo $NEW_HOSTNAME > /etc/hostname

        if [[ -z $NO_SET_HOSTNAME ]]; then
            say "run hostname command"
            hostname -F /etc/hostname
        fi

        local user
        user=${LIVE_USER:-demo}
        if ! grep -q "^$user:" /etc/passwd; then
            say "Set up live user account $(pq $user)"
            grep -q "^$user:" /etc/group || groupadd $user
            local user_pw
            user_pw=$(mkpasswd -m sha-512 $user)
            useradd -s ${ISO_SHELL:="/bin/bash"} -g $user -d /home/$user -p $user_pw $user
        fi

        gather_say user-groups "Add $(pq $user) to $(pqn %n) group%s"

        # add conveinence group vboxsf even if virtualbox guest additions
        # aren not installed
        ! is_antiX && ! grep -q vboxsf /etc/group && groupadd --system vboxsf

        local group
        for group in $(gather user-groups); do
            usermod -a -G $group $user
        done

        say "Set root password"
        local root_pw
        root_pw=$(mkpasswd -m sha-512 root)
        usermod -p $root_pw root

        end_part_strict
    fi

    if do_part 18 "Run second apt-get -f install"; then

        if [[ $DEBIAN_RELEASE != "wheezy" ]] && is_antiX; then
            apt-get $APT_GET_OPTS purge systemd libsystemd0 udev software-properties-common software-properties-gtk
            apt-get $APT_GET_OPTS install --reinstall eudev
            update-rc.d udev defaults
        fi

        apt-get -f $apt_yes install
        # Remove unwanted apps that may have sneaked in.
        say "Run $(pq "apt-get autoremove")"
        apt-get $APT_GET_OPTS autoremove
        end_part_lax
    fi

    local desktop_file default_desktop
    get_template_file default-desktop desktop_file \
        && default_desktop=$(cat $desktop_file 2>/dev/null)

    check_errors_strict

    if is_antiX; then
        if [[ -n $default_desktop ]] && do_part 19 "!Update SLiM defaults"; then

            if ! test -x $make_xinitrc; then
                mkdir -p $(dirname $make_xinitrc)    || my_exit
                cp $tools/make-xinitrc $make_xinitrc || my_exit
            fi

            say "Found desktops $(pq $($make_xinitrc --list))"

            say "Create .xinitrc in /etc/skel"
                $make_xinitrc "$default_desktop" > /etc/skel/.xinitrc \
                || error "Failed to create/update .xinitrc file"

            if [[ -e /etc/slim.conf ]]; then
                say "Update /etc/slim.conf"
                $make_xinitrc --slim || error "Failed to update slim.conf"
            fi

            end_part_strict
        else
            skip_part 19 "Update SLiM defaults"
        fi
    fi

    if is_antiX; then
        say "Customize Mozilla Browser"
        customize_firefox $LOCALE
    else
        ln -fs /usr/share/zoneinfo/America/New_York /etc/localtime
    fi

    _say_
    say "Write version files"
    write_version_files

    if ! is_antiX; then
        mv /etc/antix-version /etc/mx-version
        ln -frs /etc/mx-version /etc/antix-version

        ##fix at-spi-dbus.desktop startup sequence
        if [ -e /etc/xdg/autostart/at-spi-dbus-bus.desktop ]; then
            cp /etc/xdg/autostart/at-spi-dbus-bus.desktop /etc/xdg/autostart/zz-at-spi-dbus-bus.desktop
            rm /etc/xdg/autostart/at-spi-dbus-bus.desktop
        fi

        ##mask cgmanager.service - not needed for systemd and masking won't prevent sysVinit from using it.
        systemctl mask cgmanager.service

    fi

    mkdir -p /usr/share/antiX

    dpkg-query -l | sed -n 's/^ii\s\+//p' > $output_dir/package-list.out
    dpkg-query -l | sed -n 's/^ii\s\+//p' > /usr/share/antiX/installed-packages.txt

    # It is easier to do this outside the chroot but by doing it here, the
    # updatedb database will contain the theme files
    if [[ -n $THEME && $THEME != none ]] && do_part 20 "Apply Theme"; then
        apply_theme $THEME
        check_errors_reset
        end_part_strict
    fi
    #-----------------------------------------------------------------
    if ! is_antiX; then
        # fix debian frontend
        say "Configure debconf interface:"
        case $(dpkg-query -f '${db:Status-Abbrev}' -W  debconf-kde-helper 2>/dev/null) in
           i*)
             say "Set debconf frontend: Kde"
             debconf-set-selections < <(printf "debconf\tdebconf/frontend\tselect\tKde\n")
             ;;
           *)
             say "Set debconf frontend: Gnome"
             debconf-set-selections < <(printf "debconf\tdebconf/frontend\tselect\tGnome\n")
             ;;
        esac
    fi
    #-----------------------------------------------------------------

    local partial_dir=/var/cache/apt/archives/partial
    say "Fix $(pq $partial_dir) directory"
    mkdir -p $partial_dir
    chown _apt:root -R $partial_dir
    chmod 700 $partial_dir

    if ! is_antiX; then

    say "fix apparmor profile for smbd"
        if [ -e /etc/apparmor.d/samba/smbd-shares ]; then
            echo "skip apparmor config"
        else
            [[ -d /etc/apparmor.d/samba ]] || mkdir -p /etc/apparmor.d/samba
            touch /etc/apparmor.d/samba/smbd-shares
        fi
    fi

    local update_cmd=updatedb
    say "Run $update_cmd"
    echo 3 | sudo tee /proc/sys/vm/drop_caches >/dev/null
    sleep 2
    mount -t tmpfs -o size=100k tmpfs /var/cache/apt/archives
    $update_cmd --add-prunepaths /var/cache/apt/archives/ || error "The $(pqw $update_cmd) program failed"
    $update_cmd || error "The $(pqw $update_cmd) program failed"
    umount /var/cache/apt/archives
    sleep 2
    echo 3 | sudo tee /proc/sys/vm/drop_caches >/dev/null
    # We send on the exact kernel name we found
    echo "K_NAME=\"$K_NAME\"" > $output_file

    _say_ "$num_co===============================================================$nc"
    SIGN_OFF="$text_co$ME in chroot done$nc"

    rm -f $partial_file
    leave_stage
    my_exit
}

apply_theme() {
    export ISO_ARCH
    local theme=${1:-$THEME}
    [[ $theme = none ]] && return

    local t_dir short_t script
    t_dir=$theme_dir/$THEME
    short_t=$(short_dir $t_dir)
    [[ ! -d $t_dir ]] \
        && error "Theme directory $(pq short_t) does not exist" && return

    local script=$t_dir/theme.sh short_script=$short_t/theme.sh
    [[ ! -e $script ]] && \
        error "Theme script $(pq $short_script) does not exist" && return

    [[ ! -x $script ]] && \
        error "Theme script $(pq $short_script) is not executable" && return

    say "Applying theme $(pq $theme)"
    $script --functions --VERBOSE  && return

    error "There was an error processing the theme script"
}

#------------------------------------------------------------------------------
# Stage 5
#------------------------------------------------------------------------------
do_stage_5() {
    enter_stage 5 "Finalize and clean the chroot"

    check_sqfs_dir

    sleep 2

    if is_antiX && do_part 21 "!Check kernel's GCC version"; then
        check_kernel_gcc vmlinuz-$K_NAME
        end_part_strict
    fi

    if [[ $FLAV = "base" ]]; then
        say "Change fluxbox and icewm menu-applications files"
        sudo mv -f $sqfs_dir/usr/share/desktop-menu/.fluxbox/menu-applications-fb $sqfs_dir/usr/share/desktop-menu/.fluxbox/menu-applications
        sudo mv -f $sqfs_dir/usr/share/desktop-menu/.icewm/menu-applications-ice $sqfs_dir/usr/share/desktop-menu/.icewm/menu-applications
    fi

    local f wm
    say "Change ownership of 3 menu-applications files"
    for wm in fluxbox icewm jwm; do
        f=$sqfs_dir/usr/share/desktop-menu/.$wm/menu-applications
        [[ -e $f ]] && $SUDO chown 1000:1000 $f
    done

    if is_antiX; then
        say "Change permissions for 2 ppp files"
        $SUDO chmod 666 $sqfs_dir/etc/ppp/chap-secrets
        $SUDO chmod 666 $sqfs_dir/etc/ppp/pap-secrets

         #say "Disable exec for 2 icewm files"
         #$SUDO chmod 644 $sqfs_dir/usr/bin/icewmbg
         #$SUDO chmod 644 $sqfs_dir/usr/bin/icewm-menu-fdo

        if [[ $DEBIAN_RELEASE != "wheezy" && -z "$jbb_mode" ]] && is_antiX; then
            say "Compress /usr/share/doc then delete folder"
            tar -jcvf doc-$full_distro_name.tar.bz2 -C / ${sqfs_dir#/}/usr/share/doc
            sleep 1
            $SUDO find $sqfs_dir/usr/share/doc -type f -name "*.gz" -delete
            $SUDO find $sqfs_dir/usr/lib -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/gdebi/GDebi/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/python3 -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/python3/debpython -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/python3/__pycache__  -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/python3/debpython/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/streamlink/streamlink_cli/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/streamlink/streamlink_cli/utils/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/streamtuner2/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/streamtuner2/bundle/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/streamtuner2/channels/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/system-config-printer/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/system-config-printer/troubleshoot/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/system-config-printer/xml/__pycache__ -type f -name "*.pyc" -delete
        fi
    fi

    say "Write initrd_release file"
    write_initrd_release $sqfs_dir $SUDO

    say "Clean out log files and other files"
    for f in $(gather delete-files); do
        eval $SUDO rm -rf $sqfs_dir/$f 2>/dev/null
    done

    (cd $sqfs_dir/var/log && $SUDO touch apt/history.log apt/term.log dpkg.log)

    say "Delete $(pq "/dev/*") in chroot"
    mountpoint -q $sqfs_dir/dev && fatal "$(pqw /dev) is still mounted in squashfs!"
    $SUDO rm -rf $sqfs_dir/dev
    $SUDO mkdir $sqfs_dir/dev

    # Clean up our loose ends (once here instead of after every chroot)
    $SUDO rm -rf $sqfs_dir$build_dir

    # We used LOCAL_MIRROR while building inside the chroot
    set_chroot_mirror $MIRROR "DEFAULT mirror"

    say "Delete $(pq /etc/mtab)"
    $SUDO rm -f $sqfs_dir/etc/mtab

    say "Customize configuration"
    copy_template_dir -o custom-config-files $sqfs_dir

    if is_antiX; then
        say "Add folders for sane"
        $SUDO mkdir $sqfs_dir/usr/lib/sane
        sleep 1
        $SUDO mkdir $sqfs_dir/usr/lib64/sane

        #collect_live_files $live_files_list /usr/local/share/live-files
        say "Save Live files for snapshot"

        $SUDO rm -rf $sqfs_dir/usr/local/share/live-files
        $SUDO $tools/installed-to-live populate-live-files $sqfs_dir $sqfs_dir

        if [[ $FLAV = "core" ]] && is_antiX; then
            local if_file=$sqfs_dir/etc/network/interfaces
            if ! grep -q eth0 $if_file; then
                say "Adding eth0 entry to $(pq ${if_file#"$sqfs_dir"})"
                cat << Eth0_entry | $SUDO tee -a $if_file >/dev/null

# The primary network interface
allow-hotplug eth0
iface eth0 inet dhcp
Eth0_entry
            fi
        fi
    fi

    local cached=$sqfs_dir/etc/console-setup/cached_setup_keyboard.sh
    if test -e $cached; then
        say "Removing console-setup cached files"
        $SUDO rm $cached*
    fi

    local exclude_files="$sqfs_dir/usr/local/share/excludes/*.list"
    local efile ofile
    for efile in $exclude_files; do
        ofile=${efile%.list}.orig
        $SUDO cp $efile $ofile
        $SUDO chmod a-wx $ofile
    done

    local bc_fw_bin=$sqfs_dir/lib/firmware/brcm/brcmfmac4350-pcie.bin
    local bc_fw_txt=${bc_fw_bin%.bin}.txt
    local bc_fw_name
    bc_fw_name=$(basename $bc_fw_bin)

    if test -e $bc_fw_bin && ! test -e $bc_fw_txt; then
        say "Linking to $(pq $bc_fw_name)"
        $SUDO ln -s $bc_fw_name $bc_fw_txt
    fi

    local vim_bin=$sqfs_dir/usr/bin/vim
    if [[ -x $vim_bin.tiny && ! -e $vim_bin ]]; then
        say "Making /usr/bin/vim symlink to vim.tiny"
        $SUDO ln -s vim.tiny $vim_bin
    fi

    local cdrecord_bin=$sqfs_dir/usr/bin/cdrecord
    local wodim_bin=$sqfs_dir/usr/bin/wodim
    if is_antiX && [[ -x $wodim_bin && ! -e $cdrecord_bin ]]; then
        say "Making /usr/bin/cdrecord symlink to wodim"
        $SUDO ln -s wodim $cdrecord_bin
    fi

    local cli_cc_prog=antiX-cli-cc
    if test -x $sqfs_dir/usr/local/bin/$cli_cc_prog; then
        local dir file
        for dir in /root /etc/skel; do
            file=$sqfs_dir$dir/.bash_history
            #$SUDO test -e $file && continue

            say "Putting command line control centre into Bash history in $(pq $dir)"
            echo $cli_cc_prog | $SUDO tee $file >/dev/null
        done

    # Make sure root's history is either clobbered (above) or erased
    elif $SUDO test -e $sqfs_dir/root/.bash_history; then
        say "Deleting root's history"
        $SUDO rm -f $sqfs_dir/root/.bash_history
    fi

    if ! is_antiX; then
        #remove symlink for /etc/resolv.conf
        say "Removing symlink for /etc/resolv.conf"
        $SUDO rm -f $sqfs_dir/etc/resolv.conf

        #remove old linux image files
        say "Removing *.old files from / "
        $SUDO rm -f $sqfs_dir/*.old
    fi

    leave_stage
}

#------------------------------------------------------------------------------
# Stage 6
#------------------------------------------------------------------------------
do_stage_6() {
    enter_stage 6 "Prepare iso directory"
    # (0) Populate iso dir with boilerplate files
    # (1) Copy flavour-dependent bootloader.cfg files via inheritance
    copy_template_dir -u iso $iso_dir

    say "Make/customize bootloader configuration"

    # Directories under iso/
    local isolinux_dir=$iso_dir/boot/isolinux
    local syslinux_dir=$iso_dir/boot/syslinux

    # Directories with unpacked cpio archives
    local isolinux_cpio=$work_dir/isolinux-cpio
    local syslinux_cpio=$work_dir/syslinux-cpio

    unpack_gfx_cpio isolinux $isolinux_cpio
    unpack_gfx_cpio syslinux $syslinux_cpio

    # (2) Let bootloader know if we use a 64-bit kernel
    [[ $ARCH = amd64 ]] && echo 1 > $isolinux_cpio/64bit
    [[ $ARCH = amd64 ]] && echo 1 > $syslinux_cpio/64bit

    # (3) Update Fn menu in bootloader
    local boot_menu
    get_template_file gfxboot.menu boot_menu
    if [[ -n $boot_menu ]]; then
        update_gfxboot_menu $boot_menu $isolinux_cpio/gfxboot.cfg
        update_gfxboot_menu $boot_menu $syslinux_cpio/gfxboot.cfg "key.F8=save"
    fi

    # (4) Mostly for flavour dependent desktop.men file
    #     could also be used to over-write add other files in the gfx-cpio
    copy_template_dir -u gfx-cpio $isolinux_cpio
    copy_template_dir -u gfx-cpio $syslinux_cpio

    # (5)
    say "Fill in bootloader template files"
    local bootloader_data=$output_dir/bootloader-data
    eval local boot_options=\$${DISTRO_NAME}_LIVE_BOOT_OPTIONS
    cat << Bootloader_Data > $bootloader_data
      DISTRO_NAME="$DISTRO_NAME"
   DISTRO_VERSION="$DISTRO_VERSION"
 FULL_DISTRO_NAME="$full_distro_name"
         ISO_ARCH="$ISO_ARCH"
        CODE_NAME="$CODE_NAME"
             FLAV="$FLAV"
          OPTIONS="$boot_options"
     CORE_OPTIONS="$CORE_LIVE_BOOT_OPTIONS"
     RELEASE_DATE="$RELEASE_DATE"
Bootloader_Data

    $SUDO mkdir -p $sqfs_dir/usr/share/antiX/
    $SUDO cp $bootloader_data $sqfs_dir/usr/share/antiX/

    $tools/bootloader-template -i --data=$bootloader_data $iso_dir
    $tools/bootloader-template -i --data=$bootloader_data $isolinux_cpio/en.hlp
    $tools/bootloader-template -i --data=$bootloader_data $syslinux_cpio/en.hlp

    # (6) Create/append-to text-only bootloader menu (.msg file)
    local isolinux_cfg=$isolinux_dir/isolinux.cfg
    local syslinux_cfg=$syslinux_dir/syslinux.cfg

    if [[ -n $MEM_TEST_BUG ]]; then
        say "Comment out memtest in $(basename $syslinux_cfg)"
        sed -i "/memtest/,$ s/^/#--memtest /" $syslinux_cfg
    fi

    $tools/make-isolinux-menu $isolinux_cfg >> $isolinux_dir/readme.msg
    $tools/make-isolinux-menu $syslinux_cfg >> $syslinux_dir/readme.msg

    # (7) Enabled "Save" menu on syslinux side only
    sed -r -i "/key\.F.=save/ s/^\s*;+\s*//" $syslinux_cpio/gfxboot.cfg

    # (7.1) add ask+save entry to syslinux console menu
    local con_menu=$syslinux_cpio/console.men
    grep -q "ask+save" $con_menu || echo "ask+save \`vga=ask gfxsave" >> $con_menu

    # (8) Create/update text (UEFI) desktop menu based on menu in isolinux cpio archive
    local desktop_men=$isolinux_cpio/desktop.men
    if test -e $desktop_men; then
        say "Create desktop text boot-menu"
        $SUDO $tools/make-text-menu desktop $boot_menu_dir $desktop_men
        local append_menu dir targ
        get_template_file append-to-desktop.men append_menu
        for dir in $isolinux_cpio $syslinux_cpio; do
            targ=$dir/desktop.men
            test -e $targ || continue
            say "Append to $(basename $dir)/$(basename $targ)"
            cat $append_menu >> $targ
        done
    fi

    # (9)
    sed -i 's/APPEND hd0/APPEND hd1/' $syslinux_dir/syslinux.cfg

    # (10)
    if [[ $FLAV = "core" ]]; then
        say "Use large font in bootloader for $(pq $FLAV) system"
        sed -i "s/16x16.fnt/16x16aa.fnt/"  $isolinux_cpio/gfxboot.cfg $syslinux_cpio/gfxboot.cfg
    fi

    # say "Make efi.img"
    # $SUDO $tools/make-efi-img $iso_dir "$DISTRO_NAME-uefi"

    repack_gfx_cpio isolinux $isolinux_cpio
    repack_gfx_cpio syslinux $syslinux_cpio

    echo "$fancy_name" > $iso_dir/version

    local sneaky=".disk"
    say "Add sneaky $sneaky/ directory"
    mkdir -p $iso_dir/$sneaky
    cp $iso_dir/version $iso_dir/$sneaky/info


    if [[ -z $iso_only ]]; then
        # Copy the kernel from the squashfs
        say "Copy kernel $(pq $K_NAME) to $(pq vmlinuz) in iso directory"
        local kernel_file=$sqfs_dir/boot/vmlinuz-$K_NAME
        [[ -r $kernel_file ]] || error "Could not find kernel ${kernel_file##*squashfs} in squashfs dir"

        local vmlinuz=$iso_dir/antiX/vmlinuz
        mkdir -p $iso_dir/antiX
        cp $kernel_file $vmlinuz || my_exit
        md5sum_file $vmlinuz
    fi

    # Create custom initrd.gz including modules from the squashfs kernel
    if [[ -e $initrd_dir ]]; then
        say "Clear out initrd directory"
        rm -rf $initrd_dir
    fi

    mkdir -p $initrd_dir

    local initrd_src=$template/COMMON/initrd

    if [[ -d $initrd_src ]]; then
        copy_template_dir -u initrd $initrd_dir
    else
        error "No $initrd_src/ or $initrd_src.gz found"
    fi

    say "Write initrd_release file"
    write_initrd_release $initrd_dir

    is_antiX && initrd_encrypt="--encrypt"

    if [[ -z $iso_only ]]; then
        say "Copy $(pq $K_NAME) modules into initrd"

        rm -rf $initrd_dir/lib/modules/

        # Note: please use built-in list so we are all in sync. Thanks!     #anticap
        $tools/copy-initrd-modules $initrd_encrypt --very-quiet --kernel $K_NAME --from $sqfs_dir --to $initrd_dir --count

        #anticap#$tools/copy-initrd-programs --to $initrd_dir --clean
        $tools/copy-initrd-programs $initrd_encrypt --quiet --to $initrd_dir --from $sqfs_dir
    fi

    local initrd_gz=$iso_dir/antiX/initrd.gz
    say "Create initrd.gz"
    (cd $initrd_dir && find . | cpio -o -H newc --owner root:root --quiet) \
        | $GZIP -9 > $initrd_gz

    md5sum_file $initrd_gz

    [[ -z "$iso_only" ]] && copy_second_kernel $sqfs_dir/boot $iso_dir/antiX

    say "Write auxiliary information"

    [[ $iso_only ]] && touch $work_dir/package-list.out

    local misc_dir=$iso_file_dir/misc/$full_distro_name
    mkdir -p $misc_dir
    gather package                               > $misc_dir/package-list.antiX
    gather exclude-bootstrap                     > $misc_dir/exclude-list
    pretty_output | strip_color                  > $misc_dir/info
    awk '{ print $1}' $work_dir/package-list.out > $misc_dir/package-list.all
    write_version_info                           > $misc_dir/version-info

    cp $work_dir/package-list.out                  $misc_dir/package-list.full

    say "Initializing random number generator"
    local seed_file=$iso_dir/antiX/$seed_fname
    dd status=none if=/dev/urandom of=$seed_file bs=1 count=512

    leave_stage
}

#------------------------------------------------------------------------------
# Stage 7 creates the squashfs file
#------------------------------------------------------------------------------
do_stage_7() {
    enter_stage 7 "Create squashfs file"
    umount_chroot

    say "Run depmod one last time"
    $SUDO depmod --basedir $sqfs_dir $K_NAME

    say "Clear /run directory"
    $SUDO rm -rf $sqfs_dir/run
    $SUDO mkdir -p $sqfs_dir/run

    say "Run updatedb one last time"
    $SUDO chroot $sqfs_dir /usr/bin/updatedb

    say "Update font cache"
    $SUDO chroot $sqfs_dir fc-cache -r -s -v

    if ! is_antiX; then
        $SUDO chroot $sqfs_dir fc-cache -r -v /usr/share/fonts/extra
        [[ -d $sqfs_dir/etc/skel/.cache/fontconfig ]] || \
            $SUDO mkdir -p $sqfs_dir/etc/skel/.cache/fontconfig

        $SUDO rm -f $sqfs_dir/etc/skel/.cache/fontconfig/*
        $SUDO cp $sqfs_dir/var/cache/fontconfig/* $sqfs_dir/etc/skel/.cache/fontconfig/
    fi

    if  [[ -n $zstd_override ]]; then
        COMPRESSION_TYPE="zstd"
        COMPRESSION_TYPE_CODE="-comp zstd -Xcompression-level 15 -b 262144"

    elif [[ -n $lz4_override ]]; then
        COMPRESSION_TYPE="lz4"
        COMPRESSION_TYPE_CODE="-comp lz4 -Xhc"
    fi

    say "Build the $COMPRESSION_TYPE compressed linuxfs file. This takes time and uses a lot of CPU power."

    local linuxfs_file=$iso_dir/antiX/linuxfs
    rm -f $linuxfs_file

    start_timer
    #                                                    262144 = 0x40000
    #$SUDO mksquashfs $sqfs_dir $linuxfs_file -comp xz -b 262144

#also capture uncompressed filesystem output into a variable and place that in a file in the SQFILE_DIR location

    local output="/tmp/mksquash_output"
    local UNCOMPRESSEDSIZE_FILE UNCOMPRESSEDSIZE
    UNCOMPRESSEDSIZE_FILE="$iso_dir/antiX/linuxfs.info"
    $SUDO unbuffer -p mksquashfs $sqfs_dir $linuxfs_file $COMPRESSION_TYPE_CODE | tee $output
    UNCOMPRESSEDSIZE=$(grep "uncompressed filesystem" "$output" | cut -d"(" -f2 | cut -d" " -f1)
    echo "UncompressedSizeKB=$UNCOMPRESSEDSIZE">"$UNCOMPRESSEDSIZE_FILE"
    rm "$output"
    local size
    size=$(du_size $linuxfs_file)
    end_timer "create $(pqn $size) squashfs file"
    md5sum_file $linuxfs_file

    leave_stage
}

#------------------------------------------------------------------------------
# Stage 8 creates the iso file.
#------------------------------------------------------------------------------
do_stage_8() {
    enter_stage 8 "Create iso file"

    report_size $iso_dir

    local iso_file=$full_distro_name.iso
    mkdir -p $iso_file_dir
    local full_iso_file=$iso_file_dir/$iso_file
    say "Build the live $(pq $iso_file) file"

    local file full
    for file in vmlinuz linuxfs initrd.gz; do
        full=$iso_dir/antiX/$file
        test -e $full && md5sum_file $full
    done

    start_timer

    local file_dir chown_opts
    file_dir="$full_iso_file $iso_dir"
    chown_opts="-uid 0 -gid 0"
    say "Using $(pq $(basename $MAKE_ISO)) to make iso file"
    if [[ -z ${MAKE_ISO%%*xorriso} ]]; then
        $SUDO chown -R root:root $iso_dir
        make_xorriso_iso $MAKE_ISO $file_dir
        $SUDO chown -R $UID $iso_dir

    elif has_option $MAKE_ISO -e; then
        make_uefi_iso "$MAKE_ISO" "$chown_opts -e" $file_dir

    elif has_option $MAKE_ISO -eltorito-platform; then
        make_uefi_iso "$MAKE_ISO" "$chown_opts -eltorito-platform 0xEF -eltorito-boot" $file_dir

    else
        warn "Disabling 'dd' live-usb UEFI booting"
        $MAKE_ISO -l -V antiXlive -R -J -pad -no-emul-boot -boot-load-size 4  \
            -boot-info-table -gid 0 -uid 0 -b boot/isolinux/isolinux.bin      \
            -c boot/isolinux/isolinux.cat -o $full_iso_file $iso_dir 2>&1 \
            || error "iso file creation failed"

            isohybrid $full_iso_file
    fi

    size=$(du_size $full_iso_file)
    end_timer "create $(pqn $size) iso file"

    if [[ $SIGN_FILES == true ]]; then
        say "Sign $(basename $full_iso_file)"
        rm -f $full_iso_file.sig 2>/dev/null
        local gpg_sudo
        is_antiX && gpg_sudo=$SUDO
        $gpg_sudo gpg --output $full_iso_file.sig --detach-sign $full_iso_file
    fi

    md5sum_file $full_iso_file
    sha256sum_file $full_iso_file
    zsyncmake_file $full_iso_file


    if is_antiX && [[ -L "$ISO_SYMLINK" ]];then
        say
        say "Create symlink $(pq $ISO_SYMLINK) to iso file"
        ln -sf $full_iso_file $ISO_SYMLINK
    fi

    say2 "Your live $(pq $iso_file) is in $(pq Remaster/iso-files) ready to be tested"

    if [[ -z $full_auto ]] && mountpoint -q $sqfs_dir; then
        echo
        yell "Run $(pqw $ME) again or run $(pqw $ME -F) to cache and umount the tmpfs"
        yell "Or use the $(pqw "-A (--AUTO)") flag next time to do this automatically"
       echo
   fi

    leave_stage

    echo "$text_co$ME$bold_co done$nc" > $sign_off_file
    # Go on to final stage when in auto-mode
    [[ -n $full_auto ]]  || my_exit
}

#------------------------------------------------------------------------------
# State 9 cleans things up and clears the stage for staring over.
#------------------------------------------------------------------------------
do_stage_9() {

    enter_stage 9 "Clean up and prepare to start over"

    local s links
    for s in initrd iso sqfs work; do
        [[ -L $script_dir/$s ]] && links="$links $script_dir/$s"
    done

    umount_tmpfs
    clear_outputs

    local rel_work_dir
    rel_work_dir=Remaster/work/$(basename $work_dir)
    if [[ -n $delete_all ]]; then
        say "Delete entire work directory $(pq $rel_work_dir)"
        $SUDO rm -rf $work_dir
        [[ -n $links ]] && rm $links

    elif [[ -n $delete_mode ]]; then
        say "Delete squashfs directory $(pq $rel_work_dir/squashfs)"
        $SUDO rm -rf $sqfs_dir
        rm -f $script_dir/squashfs

        if yes_NO "Delete everything else in $(pq $rel_work_dir)"; then
            $SUDO rm -rf $work_dir
            [[ -n $links ]] && rm $links
        fi

    elif yes_NO "Delete entire work directory $(pq $rel_work_dir)"; then
        $SUDO rm -rf $work_dir
        [[ -n $links ]] && rm $links

    elif yes_NO "Delete squashfs directory $(pq $rel_work_dir/squashfs)"; then
        $SUDO rm -rf $sqfs_dir
        rm -f $script_dir/sqfs
    fi

    my_exit
}

do_save() {
    [[ $stage -gt 0 ]] || return 1
    force_cache $chroot_cache_opts
    return 0
}

#------------------------------------------------------------------------------
# enter_stage stage title
# $1 is used when we grep and sed ourselves to find out info about the various
# stages. See do_pretend() and --show-stages.
#
# titles starting with "!" skip the continue question. Make sure we don't get
# caught in an endless loop. Usually only needed during development.
#------------------------------------------------------------------------------
enter_stage() {
    title=${2#!}

    has_word EXIT_STAGE $stage && vexit "via EXIT_STAGE=$EXIT_STAGE ${text_co}at stage $(pqn $stage)$nc"
    grep ^$stage$ $did_stage_file && fatal "Re-entering stage $stage"

    _say_ "\n${bold_co}Stage $num_co$stage$text_co: $title$nc @ $(date +"%F %T %Z")"
    [[ -z $quiet_mode && $stage -gt 0 ]] \
        && say "Making: $(pq $full_distro_name) with kernel $(pq $K_NAME)"

    has_word  ASK_STAGE $stage \
        && YES_no "ASK_STAGE: Exit" && vexit "${text_co}at stage $(pqn $stage)$nc"

    echo $stage >> $did_stage_file

    [[ -z $auto_mode && ! $2 =~ ^! ]] \
        && ! YES_no_loud "\nDo you want to continue" && my_exit

    touch $err_file
    check_errors_reset

    start_timer STAGE_TIME
    return 0
}

leave_stage() {
    touch $output_file
    [[ $# -gt 0 ]] && return
    _end_timer_ STAGE_TIME "Stage $stage"
    check_errors_strict
    return 0
}
#==============================================================================
# Routines for tmpfs mounts
#==============================================================================

mount_tmpfs() {
    local dir needed name
    dir=${1:-$sqfs_dir}
    needed=$(((TMPFS_SIZE * $(gather_cnt package))/ 10 ))
    name=$(basename $dir)

    [[ -n $dir ]] || fatal "Can't mount_tmpfs() without a directory specified"

    if mountpoint -q $dir; then
        say "tmpfs is already in use"
        return
    fi
    local cache free swap
    eval $(get_cache_free_swap)
    say "The tmpfs will require $(pqn ${needed}) meg of RAM"
    display_cache_free_swap $cache $free $swap

    local balance=$((free + swap - needed))
    [[ $balance -lt 0   ]] && fatal "Need more memory than is available in RAM and swap"
    [[ $balance -lt 200 ]] && error "Less than 200 Meg memory margin (free RAM + swap - needed)"

    YES_no "Mount as tmpfs" || return

    # Try to make a backup if directory exists and is not empty
    if [[ -d $dir ]] && [[ -n $(ls $dir) ]]; then
        if [[ ! -d $dir.bak ]]; then
            say "Save $name dir at $name.bak"
            mv $dir $dir.bak
        else
            say "Not saving $name/ because $name.bak already exists"
        fi
    fi

    say "mount $(pq $name/) as tmpfs size: $(pqn ${needed})m"

    mkdir -p $dir
    if ! $SUDO mount -t tmpfs -o noatime,size=${needed}m tmpfs $dir; then
        check_errors_reset
        error "Failed to mount $name/ as tmpfs"
    fi
}

umount_tmpfs() {
    local dir name
    dir=${1:-$sqfs_dir}
    name=$(basename $dir)

    [[ -n $dir ]] || fatal "Can't umount_tmpfs() without a directory specified"

    mountpoint -q $dir || return

    say "About to umount $(pq $name)"
    report_size $dir
    YES_no_loud "Cache chroot directory before umount" && force_cache $chroot_cache_opts

    YES_no_loud "Clear out $name/ and umount it" || return 1

    check_sqfs_dir $dir
    $SUDO rm -rf $(dirname $dir)/squashfs/*
    $SUDO umount $dir
    mountpoint -q $dir || return
    warn "name did not simply umount. Trying -l (lazy option)"
    $SUDO umount -l $dir
    mountpoint -q $dir || error "Could not umount $name"

}

find_all_tmpfs() {
    local dir type name
    for dir in "$remaster_dir"/work/*/squashfs; do
        [[ -d $dir ]]          || continue
        mountpoint -q $dir   || continue
        type=$(df -Tm $dir | awk '{type=$2} END {print type}')
        [[ $type = tmpfs ]]  || continue
        name=${dir#"$remaster_dir"/work/}
        echo ${name%/squashfs}
    done
}

check_all_tmpfs() {
    local name dir used size all_tmpfs cnt
    all_tmpfs=$(find_all_tmpfs)
    [[ -n $all_tmpfs ]] || return 1
    cnt=$(echo "$all_tmpfs" | wc -w)
    psay $cnt "Found $(pqn %n) tmpfs mount point%s"

    for name in $all_tmpfs; do
        display_tmpfs $name
    done

    YES_no "Cache or umount any of these" || return 0

    for name in $all_tmpfs; do
        echo
        local dir=$remaster_dir/work/$name/squashfs
        display_tmpfs $name
        YES_no_loud "Cache chroot directory before umount" && force_cache chroot $name $dir
        YES_no "Clear and umount this directory" || continue

        $SUDO rm -rf $(dirname $dir)/squashfs/*
        $SUDO umount -l $dir
    done

    return 0
}

display_tmpfs() {
    local name=$1
    local fmt dir sizes
    fmt="    $high_co%-35s $(pqn %6s)/$(pqn %s) meg$nc\n"
    dir=$remaster_dir/work/$name/squashfs
    sizes=$(df -m $dir | awk '{size=$2; used=$3} END {print used " " size}')
    printf "$fmt" "$name" $sizes
}

kill_chroot_procs() {
    local pids
    pids=$($SUDO lsof | grep $sqfs_dir | tail -n +2 | awk '{print $2}' | sort -u)
    if [[ -z $pids ]]; then
        say "No remaining chroot processes found"
        return
    fi
    local cnt
    cnt=$(echo "$pids" | wc -l)
    psay $cnt "Found $(pqn %n) chroot process%es still running"
    _say_ "$(my_ps "$pids")"

    YES_no "Kill these processes" || return
    $SUDO kill $pids
    #FIXME check for survivors
}
#==============================================================================
# Error detection on STDERR output
#
# All the stderr output ends up in $err_file. We periodically check this file
# for new errors.
#
# check_errors_reset()
#   Ignore all previous errors
#
# check_errors_strict()
#    assume previous error messages are fatal except those matching regexes.
#
# check_errors_lax()
#    assume all errors are non-fatal except those matching a list of regexes.
#
# If $ask_errors is true then the user is given a chance to modify the list of
# strict exceptions and try again before we error out.
#==============================================================================

check_errors_reset() {
    [[ -e $err_file ]] || touch $err_file
    local offset
    offset=$(cat $err_file 2>/dev/null | wc -l)
    : ${offset:=0}
    ERROR_OFFSET=$((offset + 1))
    #_say_ "check_errors_reset"
    return 0
}

check_errors_strict() { _check_errors_ STRICT "$STRICT_EXCEPTIONS"  -v ;}
check_errors_lax()    { _check_errors_ LAX    "$LAX_ERRORS"            ;}

_check_errors_() {
    local type=$1 regex=$2 flag=$3

    [[ -n $disable_errors ]] && return
    : ${ERROR_OFFSET:=1}
    #say "Checking for $(pq $type) errors @offset $ERROR_OFFSET"
    local errors cnt
    while true; do

        if [[ -n $regex ]]; then
            errors=$(tail -n +$ERROR_OFFSET $err_file | grep -E $flag "($regex)" | grep -Ev "^\s*$")

        elif [[ $type = STRICT ]]; then
            errors=$(tail -n +$ERROR_OFFSET $err_file | grep -Ev $flag "^\s*$")
        fi

        [[ -z $errors ]] && check_errors_reset && return

        local cnt
        cnt=$(echo "$errors" | wc -l)
        if [[ -n $no_check_errors ]]; then
            say "$(plural $cnt "Skipping $(pqn %n) $type error%s")"
            return
        fi

        yell "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
        say_in $err_co "$errors"
        #_say_ "$(echo "$errors" | sed -e "s/^/$err_co/" -e "s/$/$nc/")"
        yell "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
        yell "$(plural $cnt "Found $(pqw %n) $type error%s")"
        [[ -n $ask_errors ]] || break
        YES_no "Retry"    || break
        read_error_regexes
    done

    check_errors_reset
    if YES_no "Ignore this error"; then
        say "Error ignored"
        return
    fi

    yell "Exiting"

    # Almost never needed except in middle of prep chroot stage
    clear_pids
    umount_chroot

    my_exit 1
}

read_error_regexes() {

    [[ -r $lax_regex_file ]] || error "Could not find/read lax-error file $file"
    LAX_ERRORS=$(join_lines $lax_regex_file "|")

    [[ -r $strict_regex_file ]] || error "Could not find/read strict-exception file $file"
    STRICT_EXCEPTIONS=$(join_lines $strict_regex_file "|")
}

join_lines() {
    local sep file=$1
    while read line; do
        echo -n "$sep$line"
        sep=${2:-,}
    done << Join_Lines
$(grep "[^\s]" $file)
Join_Lines

}

#==============================================================================
# Routines used inside of $chroot_stage
#==============================================================================

#------------------------------------------------------------------------------
# do_part part-num title
#
# Give user control over which parts inside of stage-3 get run.
# Time this parts and report how long each one took.
#
# Each *_PART variable can contain a comma separated list of part numbers.
# Return true if this part is supposed to run. Returns false otherwise.
# This is totally controled by the *_PART variables.
#
# For example, to only run part 4, set RUN_PART=4 SKIP_PART=a then part 4
# will run all all other parts will be skipped.
#
# Note that DID_PART is not yet implemented elsewhere. It could be used to
# make sure each part only runs once.
#------------------------------------------------------------------------------
do_part() {
    _end_part_
    local part=$1 title=${2#!}
    local pnum="$text_co$part$nc" ptitle="${title2:-$title}"
    LAST_PART=$part
    _do_part_ || return 1

    local pnum
    pnum="$(printf "%2d" $part)"

    _say_
    _say_ "${bold_co}Part $num_co$pnum$text_co: $ptitle$nc @ $(date +"%F %T %Z")"
    [[ -n $quiet_mode ]] || _say_ "Making: $full_distro_name"

    # Update window title
    echo -ne "\e]0;$ME stage:$stage part:$part $full_distro_name\a"

    LAST_TITLE=$2
    start_timer PART_TIME

    return 0
}

_do_part_() {

    if has_word SHELL_PART $part; then
        _say_ "Breakpoint at $pnum: $ptitle"
        bash --rcfile /Build/bashrc2
    fi

    # If TEST_PART is non-empty and contains at least one digit
    if [[ $TEST_PART =~ ^[0-9] ]]; then
        if ! has_word TEST_PART $part; then
            _say_ "${bold_co}Test mode:$nc Skip part ($pnum) $title"
            return 1
        fi

    elif has_word ASK_PART $part; then
        YES_no_loud "Run $nc($pnum) $ptitle" || return 1

    elif has_word RUN_PART $part; then
        return 0

    elif has_word SKIP_PART $part; then
        _say_ "Skip part ($pnum) $title"
        return 1

    fi

    return 0
}

skip_part() {
    local part=$1 pnum
    pnum="$(printf "%2d" $part)"
    _say_
    _say_ "Part $pnum: $2 -- skipped --"
}

#------------------------------------------------------------------------------
# end_part
# Report timing information about the last part that was run. Only acts the
# first time it is called after a do_part() call returns true. Is disabled if
# the previous part title begins with "!" so we don't have to time everything
# that is controlled by do_part().
#------------------------------------------------------------------------------
end_part_lax() {
    check_errors_lax
    _end_part_
}

end_part_strict() {
    check_errors_strict
    _end_part_
}

show_tmpfs_and_mem() {
    [[ -n $do_fast && "$stage" == "$chroot_stage" ]] || return
    local used total
    used=$(df -m / 2>/dev/null | awk '{used=$3}  END {print used}')
    total=$(df -m / 2>/dev/null | awk '{total=$2} END {print total}')
    say_fmt "tmpfs used"   $used
    say_fmt "tmpfs total"  $total
    display_cache_free_swap
}

_end_part_() {
    local title
    title="$(echo "$LAST_TITLE" | strip_color)"

    LAST_TITLE=
    if [[ ! $title =~ ^! ]]; then
        _end_timer_ PART_TIME "$title"
    fi

    [[ -n $LAST_PART && -w $partial_file ]] && ! grep "^$LAST_PART" $partial_file \
        && echo $LAST_PART >> $partial_file

    if  [[ -n $LAST_PART ]] && has_word EXIT_PART $LAST_PART; then
        _say_ "Exit after part ($text_co$LAST_PART$nc) $title"
        my_exit
    fi
    LAST_PART=
}

list_newer_procs() {
    local newer pid ref=${1:-$$}

    for pid in $(pgrep .); do
        [[ $pid -gt $ref ]]         || continue
        is_zombie_or_kthread $pid && continue
        newer=$newer,$pid
    done
    if [[ -n $newer ]]; then
        Say "Processes started after the chroot:"
        my_ps "$newer"
    else
        say "No newer processes found"
    fi
}

my_ps() {
    local pids=${1//[[:space:]]/,}
    [[ -n $pids ]] || return
    ps -o "$PS_FORMAT" -p ${pids#,} | sed -e "1 s/^/$text_co/" -e "1 s/$/$nc/"
}

get_cache_free_swap() {
    local lab free cache swap
    while read lab total used free shared cache available; do
        case $lab in
            Mem:) echo free=$free
                  echo cache=$cache ;;
           Swap:) echo swap=$free   ;;
        esac
    done << Get_Free
$(free -m)
Get_Free
}

display_cache_free_swap() {
    local cache=$1 free=$2 swap=$3
    [[ $# -eq 3 ]] || eval $(get_cache_free_swap)
    say_fmt "Free Mem"  $free
    say_fmt "Free Swap" $swap
    say_fmt "Cached"    $cache
}

is_zombie_or_kthread() {
    local len
    len=$(wc -c /proc/$pid/cmdline 2>/dev/null) || return 0
    [[ -z $len ]]                                     && return 0
    [[ "${len%% *}" = 0 ]]
}

#------------------------------------------------------------------------------
# search_for_k_name
# Assume K_NAME contains the name of a kernel image with "*" as a wildcard.
# Use "apt-cache search" to find all kernel images that match the pattern and
# choose the last one (which should be the highest version). Set K_NAME to
# the specfic kernel we found.
#------------------------------------------------------------------------------
search_for_k_name() {
    local search_name
    search_name=$(echo $K_NAME | sed -e "s/\./\\./g" -e "s/\*/[0-9]+/g")
    say "Search for kernel matching regex $(pq $K_NAME)"
    local name
    name=$(apt-cache search "^linux-image-$search_name$" | cut -d" " -f1 | sort -V | tail -n 1)
    if [[ -z $name ]]; then
        warn "No kernel matching $(pqw $K_NAME) found. Possible kernels:"
        apt-cache search linux-image-.\*-antix | cut -d" " -f1
        my_exit
    fi

    K_NAME=${name#linux-image-}
    say "Found kernel $(pq $K_NAME)"
}

vmlinuz_gcc_version() {
    local vmlinuz=$1
    $tools/extract-vmlinux $vmlinuz  2>/dev/null | strings \
        | sed -n -r '/gcc version/ s/.*gcc version ([0-9.]+).*/\1/p' | head -n 1
}

check_kernel_gcc() {
    local kernel=vmlinuz-$K_NAME
    local vmlinuz=$sqfs_dir/boot/$kernel
    [[ ! -r $vmlinuz ]] \
        && error "Could not find kernel file: $(pqw $kernel)" && return

    local kgcc
    kgcc=gcc-$(vmlinuz_gcc_version $vmlinuz)

    [[ $kgcc = gcc- ]] \
        && error "Could not find gcc version for $(pqw $kernel)" && return

    say "Kernel $(pq $K_NAME) was compiled with $(pq $kgcc)"

    local kalt gcc
    kalt=$(echo $kgcc | sed -n -r 's/([0-9]+\.[0-9]+)\.[0-9]+$/\1/p')

    for gcc in $kgcc $kalt; do
        [[  -e $sqfs_dir/usr/bin/$gcc ]] || continue
        say "Found $(pq $gcc) on system"
        return 0
    done
    error "Could not find these versions of gcc: $(pq $kgcc $kalt)"
}

customize_firefox() {
    local pref_files file lang=${1%%.*}
    local string="user_pref(\"spellchecker.dictionary\","

    pref_files=$(ls $firefox_prefs 2>/dev/null)
    [[ -n $pref_files ]] || return
    sed -i "/$string/d" $pref_files
    sed -i '/"extensions.lastAppVersion"/ d' $pref_files
    for file in $pref_files; do
        echo "$string \"$lang\");" >> $file
    done
}

apt_get_packages() {
    local file=$1 label=$2
    shift 2
    local pkg_list cnt msg
    pkg_list=$(compile_pkg_list $file exclude-chroot)
    cnt=$(echo "$pkg_list" | wc -w)
    [[ $cnt -eq 0 ]] && return

    msg=$(plural $cnt "apt-get ${@:$#} $(pqn %n) $label package%s.")
    [[ $cnt -ge 100 ]] && msg="$msg  This could take some time."
    say "$msg"

    echo "$pkg_list" | xargs apt-get $APT_GET_OPTS "$@"
}

install_packages() {
    local file=$1  label=$2
    shift 2
    apt_get_packages $file $label "$@" install
    check_missing $file "$label"
}

check_missing() {
    local pkg missing file=$1 label=$2 pkg_list cnt
    pkg_list=$(compile_pkg_list $file exclude-chroot)
    cnt=$(echo "$pkg_list" | wc -w)
    [[ $cnt -eq 0 ]] && return

    local installed=/Build/installed-$label

    psay $cnt "Checking that $(pqn %n) $label package%s %were installed ..."

    dpkg --get-selections | grep "install\(ed\)\?$" | sed 's/\t.*//' > $installed.list
    for pkg in $pkg_list; do
        grep -q "^$pkg\(:[A-Za-z0-9+-]\+\)\?$" $installed.list || missing="$missing$pkg\n"
    done
    if [[ -z $missing ]]; then
        say "... Okay"
        return
    fi
    dpkg --get-selections  >  $installed.raw
    echo -e "$missing"     >  /Build/missing-$label.list

    local mcnt
    mcnt=$(printf "$missing" | wc -w)
    _say_ "$high_co------------------------------------------------$nc"
    say_in $high_co "$missing"
    #_say_ "$(printf "$missing" | sed -e "s/^/$high_co/" -e "s/$/$nc/")"
    error "$(plural $mcnt "$(pqw %n) missing $label package%s")"
}

gather_deb() {
    local filt_arch filt_flav

    case $ISO_ARCH in
        x64) filt_arch="_i386\.deb$";;
        386) filt_arch="_amd64\.deb$";;
    esac

    case $ISO_RESPIN_OF in
        core) filt_flav="-base-\|-full-";;
        base) filt_flav="-core-\|-full-";;
        full) filt_flav="-base-\|-core-";;
    esac

    local dir f name deb_dir=$script_dir/Deb
    local flav=$ISO_RESPIN_OF
    for dir in $(flav_dirs $deb_dir); do
        for f in "$dir"/*.deb; do
            test -f $f || continue
            basename $f | grep -q -- $filt_arch && continue
            basename $f | grep -q -- $filt_flav && continue
            echo $f
        done
    done
}

collect_live_files() {
    local list_file=$1 dest_dir=$sqfs_dir$2
    test -r $list_file || return
    echo "Collecting Live-files"
    local list
    list=$(cat $list_file | grep -v "^\s*#\s*" | sed 's/\s*#.*//' \
        | grep "^/" | sed "s=^=$sqfs_dir=")
    #echo "$list"

    $SUDO mkdir -p $dest_dir
    # This hard-codes the live-files dir but it is safer in case
    # $dest_dir is empty.
    $SUDO rm -rf $(dirname $dest_dir)/live-files/*

    local file dest
    for file in $list; do
        test -e $file || continue
        dest_file=${file#"$sqfs_dir"}
        dest=$dest_dir$dest_file
        $SUDO mkdir -p $(dirname $dest)
        $SUDO cp -a $file $dest
    done
}

#==============================================================================
# Routines for preparing and making the iso file
#==============================================================================

has_option() {
    local prog=$1 opt=$2
    $prog --help 2>&1 | grep -q -- "$opt\s"
    return $?
}

make_uefi_iso() {
    local prog=$1 uefi=$2  file=$3 dir=$4
    local cmd="$prog -l -V antiXlive -R -J -pad -no-emul-boot
    -boot-load-size 4  -boot-info-table -b boot/isolinux/isolinux.bin
    -eltorito-alt-boot $uefi boot/grub/efi.img -no-emul-boot
    -quiet -c boot/isolinux/isolinux.cat -o $file $dir"

    echo $cmd
    $cmd 2>&1 || error "iso file creation failed"
    isohybrid --uefi $file
}

make_xorriso_iso() {
    local prog=$1 file=$2 dir=$3
    local label="$DISTRO_NAME-Live"
    local opts_1="-hfsplus on -as mkisofs -quiet -l"

    local opts_2="-R -J -iso-level 3 -pad -partition_cyl_align on"
    opts_2="$opts_2 -c boot/isolinux/isolinux.cat"
    opts_2="$opts_2 -b boot/isolinux/isolinux.bin"
    opts_2="$opts_2 -no-emul-boot -boot-load-size 4 -boot-info-table"
    opts_2="$opts_2 -eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot"
    opts_2="$opts_2 -isohybrid-apm-hfsplus -isohybrid-gpt-basdat"

    cmd="$prog $(echo $opts_1) -V $label $(echo $opts_2) -o $file $dir"
    echo $cmd

    $cmd 2>&1 || error "iso file creation failed"
    isohybrid --uefi $file
}


unpack_gfx_cpio() {
    local type=$1  dir=${2:-$work_dir/$1-cpio}  file=${3:-$iso_dir/boot/$1/gfx-cpio}
    say "Unpack $(pq $type) cpio archive"
    prep_dir $dir
    (cd $dir && cpio -idum --dot --quiet < $file 2>&1)
}

repack_gfx_cpio() {
    local type=$1  dir=${2:-$work_dir/$1-cpio}  file=${3:-$iso_dir/boot/$1/gfx-cpio}
    say "Repack $(pq $type) cpio archive"
    (cd $dir && find . -depth | cpio -o --quiet --dot --file=$file) 2>&1
}

prep_dir() {
    local dir=$1
    [[ -z $dir || ! $dir =~ [a-zA-Z] ]] && fatal "Bad directory name: $dir"
    rm -rf $dir
    mkdir -p $dir
}

update_gfxboot_menu() {
    local menu_file=$1 conf_file=$2
    shift 2
    local subdir
    subdir=$(basename $(dirname $conf_file))
    local menu_string="Function key menu"
    # Insert Function key menu into gfxboot.cfg
    [[ -e $menu_file && -e $conf_file ]] || return
    grep -q "$menu_string" $conf_file || return
    say "Update Fn key menu in $(pq $subdir/$(basename $conf_file))"
    sed -i "/$menu_string/,$ d" $conf_file
    cat << Fn_Menu >> $conf_file
; >>>>>>>>>> Function key menu >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
$(cat $menu_file)
$*
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Fn_Menu
}

#------------------------------------------------------------------------------
# Copy a 2nd kernel into iso/antiX/ and run live-multi-kernel
#------------------------------------------------------------------------------
copy_second_kernel() {
    local from_dir=$1  to_dir=$2
    local k0_name=vmlinuz  k1_name=vmlinuz1
    local vmlinuz=$to_dir/$k0_name
    local vmlinuz_1=$to_dir/$k1_name
    local version_prog=$tools/vmlinuz-version
    local lmk=$tools/live-multi-kernel

    ! test -d $from_dir       && error "boot directory $from_dir not found"   && return 1
    ! test -d $to_dir         && error "iso boot directory $to_dir not found" && return 1
    ! test -e "$vmlinuz"      && error "File $vmlinuz not found"              && return 1
    ! test -x "$version_prog" && error "Could not find program $version_prog" && return 1
    ! test -x "$lmk"          && error "Could not find program $lmk"          && return 1

    local version_0 version_1
    version_0=$($version_prog -nr $vmlinuz  |grep vmlinuz| cut -d" " -f1)
    version_1=$($version_prog -nr $from_dir | grep vmlinuz| cut -d" " -f1 | grep -v "^$version_0$")

    case $(echo -n "$version_1" | grep -c .) in
        0) return ;;
        1)        ;;
        2) echo "$version_1"
           error "more then 2 vmlinuz1 kernels found"
           return ;;
    esac

    say "Found 2nd kernel $version_1"
    local k1
    k1=$($version_prog -n $from_dir | grep " $version_1 " | cut -d" " -f1)
    say "copy $k1 $vmlinuz_1"
    cp $k1 $vmlinuz_1
    (cd $to_dir && md5sum $k1_name > $k1_name.md5)

    $lmk --distro="$DISTRO_NAME"
}

write_version_files() {
    local prefix=$1

    local version_info_file=$prefix/etc/live/version/antiX
    mkdir -p $(dirname $version_info_file)
    write_version_info > $version_info_file

    echo "$fancy_name" > $prefix/etc/antix-version

    local rstring
    rstring=$(dd status=none if=/dev/urandom bs=1 count=40 2>/dev/null | md5sum | cut -d" " -f1)
    local kernels=$K_NAME
    [[ -n $K_NAME2 ]] && kernels="$kernels $K_NAME2"
    local title=$LINUXFS_TITLE
    if [[ -z $title ]]; then
        title="Original $DISTRO_NAME $DISTRO_VERSION $ISO_ARCH"
        [[ $DISTRO_NAME =~ ^antiX && -n $FLAV ]] && title="$title $FLAV"
    fi
    local linuxfs_version_file=$prefix/etc/live/version/linuxfs.ver
    mkdir -p $(dirname $linuxfs_version_file)
    cat > $linuxfs_version_file << Linuxfs_Version
=== $rstring

title: $title
creation date: $(date +"%e %B %Y %T %Z")
kernel: $kernels
inxi version: $fancy_name
Linuxfs_Version

}

write_version_info() {
    cat << Version-Info
Distro name:$DISTRO_NAME
Version:$DISTRO_VERSION
antiX flavour:$ISO_FLAV
Kernel:$K_NAME
Code name:$CODE_NAME
Release date:$RELEASE_DATE
Made by:$ME version $VERSION ($VERSION_DATE)
Version-Info
}

write_initrd_release() {
    local dir=$1  sudo=$2  name=initrd_release
    [[ ${#dir} -eq 0 ]] && fatal "Empty directory passed to write_initrd_version()"

    local DISTRO_BASE="antiX"
    is_antiX || DISTRO_BASE="MX"

    local file1=$dir/etc/$name  file2=$dir/etc/live/version/$name
    $sudo mkdir -p $(dirname $file1) $(dirname $file2)

    : ${ASCII_CODE_NAME:=$(echo $CODE_NAME | utf8_to_ascii)}

    if [[ $ASCII_CODE_NAME != "$CODE_NAME" ]]; then

        cat << Initrd_Version | $sudo tee $file1
NAME="$DISTRO_NAME"
VERSION="$DISTRO_VERSION ($CODE_NAME)"
ASCII_VERSION="$DISTRO_VERSION ($ASCII_CODE_NAME)"
ID="$(echo $DISTRO_NAME | tr '[:upper:]' '[:lower:]')"
VERSION_ID="$(echo $DISTRO_VERSION | sed -r 's/^([0-9._-]+).*/\1/')"
PRETTY_NAME="$DISTRO_NAME $DISTRO_VERSION ($CODE_NAME)"
ASCII_PRETTY_NAME="$DISTRO_NAME $DISTRO_VERSION ($ASCII_CODE_NAME)"
ANSI_COLOR="0;34"
HOME_URL="$HOME_URL"
BUG_REPORT_URL="$BUG_REPORT_URL"
BASE=$DISTRO_BASE
Initrd_Version

    else

        cat << Initrd_Version | $sudo tee $dir/etc/initrd_release
NAME="$DISTRO_NAME"
VERSION="$DISTRO_VERSION ($CODE_NAME)"
ID="$(echo $DISTRO_NAME | tr '[:upper:]' '[:lower:]')"
VERSION_ID="$(echo $DISTRO_VERSION | sed -r 's/^([0-9._-]+).*/\1/')"
PRETTY_NAME="$DISTRO_NAME $DISTRO_VERSION ($CODE_NAME)"
ANSI_COLOR="0;34"
HOME_URL="$HOME_URL"
BUG_REPORT_URL="$BUG_REPORT_URL"
BASE=$DISTRO_BASE
Initrd_Version

    fi

    $sudo cp $file1 $file2
}

utf8_to_ascii() {
    iconv -f utf-8 -t ascii//translit
}

busybox_depmod() {
    local targ=$1  kernel=$2  cmd=${3:-depmod}

    local mod_dir=$targ/lib/modules
    local k_dir=$mod_dir/$kernel
    local to_delete

    [[ -d $targ ]]             || fatal "Target $targ is not a directory"
    [[ -x $targ/bin/busybox ]] || fatal "Could not find /bin/busybox"
    [[ -x $targ/bin/$cmd ]]    || fatal "Could not find /bin/$cmd"
    [[ -d $mod_dir ]]          || fatal "Could not find /lib/modules"
    [[ -d $k_dir ]]            || fatal "Could not find $k_dir"

    local proc_dir=$targ/proc
    if ! [[ -e $proc_dir ]]; then
        mkdir $proc_dir
        to_delete="$proc_dir $to_delete"
    fi

    touch $proc_dir/modules

    fake_dir=$mod_dir/$(uname -r)
    if [[ $fake_dir != "$k_dir" ]]; then
        ln -s $kernel $fake_dir || error "Error creating $fake_dir symlink"
        to_delete="$fake_dir $to_delete"
    fi

    $SUDO chroot $targ /bin/depmod
    for file in $to_delete; do
        echo "delete $file"
        rm -r $file
    done

    depmod_file=$k_dir/modules.dep.bb
    [[ -e $depmod_file ]] || error "The modules.dep.bb file was not created"

    $SUDO chown $USER $depmod_file
}

#==============================================================================
# Chroot related routines
#==============================================================================
do_chroot() {
    [[ $stage -ge 1 ]] || fatal "Not ready to do chroot"

    prep_chroot
    say "Enter chroot for $(pq $full_distro_name)"
    $SUDO chroot $sqfs_dir /bin/bash --rcfile /Build/bashrc
    say "Leave chroot"
    umount_chroot
    return 0
}

#------------------------------------------------------------------------------
# mount_deb_cache
# Bind mount the .deb cache directory outside the chroot so we can reuse all
# .debs that have been downloaded. This is MUCH more efficent than simply
# deleting them.
#------------------------------------------------------------------------------
mount_deb_cache() {
    local deb_dir=$sqfs_dir/var/cache/apt/archives
    mkdir -p $deb_cache_dir
    bind_mount $deb_cache_dir $deb_dir
}

#------------------------------------------------------------------------------
# bind_mount old_mp new_mp
# Common code for bind outside mounting directories in the chroot.
#------------------------------------------------------------------------------
bind_mount() {
    local old=$1 new=$2
    mountpoint -q $new && return
    $SUDO mkdir -p $new
    $SUDO mount --bind $old $new  || my_exit
    UMOUNTS="$new $UMOUNTS"
}

#------------------------------------------------------------------------------
# prep_chroot
# Mount /proc /sys and /var/cache/apt/archives in the chroot. Offer to also
# mount /dev if it appears to be empty. Create and populate the /Build dir
# in the chroot if it does not already exist. Otherwise don't touch it.
#------------------------------------------------------------------------------
prep_chroot() {
    check_sqfs_dir
    umount_chroot
    mount_deb_cache

    for fs in proc sys; do
        bind_mount /$fs $sqfs_dir/$fs
    done

    if ! [[ -e $sqfs_dir/dev/tty ]]; then
        say "Mount $(pq /dev) in the chroot"
        bind_mount /dev $sqfs_dir/dev
    fi

    if ! mountpoint -q $sqfs_dir/dev/pts; then
        say "Mount $(pq /dev/pts) in the chroot"
        bind_mount /dev/pts $sqfs_dir/dev/pts
    fi

    [[ -e $sqfs_dir/Build ]] || make_build_dir

    if ! is_antiX && [[ ! -f $sqfs_dir/etc/resolv.conf ]]; then
        $SUDO cp -H /etc/resolv.conf $sqfs_dir/etc/resolv.conf
    fi

    # Always use local mirror when working in chroot
    set_chroot_mirror $LOCAL_MIRROR "LOCAL mirror"

    # TERM helps nano to work in chroot, LC_ALL is for Deb
    export TERM=xterm LC_ALL=C
}

#------------------------------------------------------------------------------
# make_build_dir
# Create a Build/ subdirectory in the work directory. Populate it with all
# the programs and data needed to run ourselves in the chroot environment then
# move the entire directory into the chroot.
# Populate it with;
#     Ourselves
#     Deb/$ISO_ARCH-$FLAV for .deb files
#     DEFAULTS file and contents of Output/
#     Tools/ directory
#     Most of the Template/
#     ENV_IN, bashrc, and bashrc2 files
#
# A bind mount would be much simpler.
#------------------------------------------------------------------------------
make_build_dir() {

    local b_dir=$work_dir/Build
    rm -rf $b_dir
    mkdir $b_dir

    mkdir -p $b_dir/Deb
    local deb_files
    deb_files=$(gather_deb)
    [[ -n $deb_files ]] && cp --target-directory=$b_dir/Deb $deb_files

    cp -r $0 Input $tools $regex_files $b_dir

    #make custom user-defaults file defaults in chroot, if it exists and switch was used
    if [[ -n $user_default_file ]]; then
        cp $user_defaults $b_dir/Input/defaults
    fi

    mkdir $b_dir/Output
    touch $b_dir/$partial_name $b_dir/Output/$ME.log

    cp $output_dir/stage-?.out $b_dir/Output

    local cmd
    mkdir -p $b_dir/fake
    for cmd in $DUMMY_SERVICES; do
        ln -s /bin/true $b_dir/fake/$cmd
    done

    # This skips the larger subdirectories which aren't needed
    (cd $script_dir && tar cf -          \
        --exclude iso                    \
        --exclude initrd                 \
        --exclude squashfs               \
        --exclude isolinux               \
        Template)                        \
        | (cd $b_dir && tar xBf -)

    [[ -n $THEME ]] && copy_theme_dir $b_dir

    # Let chroot user over-ride values set by host system
    cat << Env_In > $b_dir/ENV_IN
: \${ASK_PART:=$ASK_PART}
: \${EXIT_PART:=$EXIT_PART}
: \${RUN_PART:=$RUN_PART}
: \${SHELL_PART:=$SHELL_PART}
: \${SKIP_PART:=$SKIP_PART}
: \${TEST_PART:=$TEST_PART}
Env_In

    local lt_blue="\e[1;34m" lt_green="\e[1;32m" lt_red="\e1;31m" nc="\e[0m"

    cat << Bashrc > $b_dir/bashrc
source ~/.bashrc
alias ls="ls --color=auto -F"
alias ll="ls --color=auto -lhF"
alias la="ls --color=auto -FA"
PS1="${lt_blue}chroot${lt_green}>$nc "
Bashrc

    cat << Bashrc2 > $b_dir/bashrc2
source /Build/bashrc
PS1="${lt_blue}breakpoint${lt_green}>$nc "
Bashrc2

    $SUDO rm -rf $sqfs_dir/Build
    $SUDO mv $b_dir $sqfs_dir
}

copy_theme_dir() {
    [[ -z $THEME || $THEME = none ]] && return
    local b_dir=$1 t_dir=$theme_dir/$THEME
    if [[ ! -d $t_dir ]]; then
        error "Theme directory $(pqw $(short_dir $t_dir)) does not exist"
        return
    fi
    local b_theme_dir
    b_theme_dir=$b_dir/$(basename $theme_dir)
    mkdir -p $b_theme_dir/$THEME
    cp -a $t_dir/* $b_theme_dir/$THEME/
    cp -a $theme_dir/*.sh $b_theme_dir/
}

#------------------------------------------------------------------------------
# umount_chroot
# Umount all fileystems mounted under any work/squashfs directory under the
# true Remaster directory. For each such mountpoint we try umounting it up to
# four times before giving up. If any such mountpoint is still a mountpoint
# after four attempts to umount it then we error out at the end of the routine.
#------------------------------------------------------------------------------
umount_chroot() {
    for mp in $(mount | cut -d" " -f3 | grep "^$remaster_dir/work/.*/squashfs/"); do
        local name=${err_co}chroot:$bold_co${mp##"$remaster_dir"/*/squashfs}

        # Don't umount the tmpfs
        [[ $mp == "$sqfs_dir" ]] && continue

        $SUDO umount -l $mp 2>/dev/null

        for try in 1 2 3; do
            mountpoint -q $mp || break
            say "umount $name"
            $SUDO umount -l $mp
            mountpoint -q $mp || break
            sleep 1
        done

        mountpoint -q $mp || continue
        warn "Still could not umount $name"
        UMOUNT_ERRORS=true
    done

    [[ -n $UMOUNT_ERRORS ]] && fatal "Umount errors!"
}

#------------------------------------------------------------------------------
# We do this outside of the chroot so we know for sure it is set correctly
# before running mksquashfs. We want it to always be local when running in
# the chroot and always be the real MIRROR when running mksquashfs.
#------------------------------------------------------------------------------
set_chroot_mirror() {
    local mirror=$1; shift
    [[ -n $mirror ]] || return

    local file=$sqfs_dir/etc/apt/sources.list.d/debian.list
    [[ -f $file ]] || return

    say "Set apt mirror to $@ $(pq $mirror)"
    $SUDO sed -i "s=/ftp\.\(..\.\)\\?debian\.org/=/ftp.$mirror.debian.org/=" $file
}

#==============================================================================
# General Utilities
#==============================================================================
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
du_size() { $SUDO du --one-file-system -sh $1 | cut -f1 | sed 's/^\s\+//'; }

convenience_link() {
    local dir=$1 link=$2 label=${3:-$2}
    [[ -z $link ]] && error "No link passed to convenience_link()" && return

    mkdir -p $dir || error "Could not create $label dir $(pqw $dir)"
    rm -f $script_dir/$link
    ln -sf $dir $script_dir/$link
}

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
report_size() {
    local name size
    name=$(basename $1)
    size=$(du_size $1)
    say "size of $name dir: $(pqn $size)"
}

#------------------------------------------------------------------------------
# check_sqfs_dir
# Mostly needed during development to prevent bad things from happening.
#------------------------------------------------------------------------------
check_sqfs_dir() {
    local dir=${1:-$sqfs_dir}

    echo $dir | grep -q "^$remaster_dir/work/.*/squashfs" \
        || fatal "Suspicous sqfs_dir in stage $stage: <$(pqw $dir)>"

    test -d $dir || fatal "sqfs_dir does not exist! in stage: $stage"
}

#------------------------------------------------------------------------------
# has_word var_name part
# See if the word "part" is incuded in the comma separated list of words in the
# variable called "name". Also return true if the words "a" or "all" are in
# the string.
#------------------------------------------------------------------------------
has_word() {
    local name=$1 part=$2
    eval val=\$$name
    case ,$val, in
            *,$part,*) return 0 ;;
        *,a,*|*,all,*) return 0 ;;
                    *) return 1 ;;
    esac
}

#------------------------------------------------------------------------------
# strip_color
# A simple filter to strip out the ANSI colors we use.
#------------------------------------------------------------------------------
strip_color() { sed -r 's/\x1b\[[0-9;]+[mK]//g'; }

cprint_left() {
    local width=$1 str=$2
    local pad=$((width - $(str_len "$str")))
    printf "%s%${pad}s" "$str" ""
}

cprint_right() {
    local width=$1 str=$2
    local pad=$((width - $(str_len "$str")))
    printf "%${pad}s%s" "" "$str"
}

str_len() {
    local msg_nc
    msg_nc=$(echo "$*" | sed -r -e 's/\x1b\[[0-9;]+[mK]//g' -e 's/./x/g')
    echo ${#msg_nc}
}

short_dir() {
    local dir=$1  pre=${2:-$script_dir}
    echo "${dir#"$pre"/}"
}


#==============================================================================
# Timer Routines
#==============================================================================
start_timer() {
    local name=${1:-START_T}
    eval $name=\"$(date +%s)\"
}

end_timer() {
    _end_timer_ START_T "$@"
}

_end_timer_() {
    local name=$1 title
    title=$(cprint_left 36 "$2")
    eval local start_t=\$$name
    _say_ "${time_co}time for $text_co$title$nc $(pqn "$(elapsed $start_t)")$nc"
}

elapsed() {
    local secs mins hours
    secs=$((-$1 + $(date +%s)))
    [[ $secs -lt 60 ]] && printf "%8d %s\n" $secs $(plural $secs "sec%s") && return
    mins=$((secs / 60))
    secs=$((secs - 60 * mins))
    [[ $mins -lt 60 ]] && printf "%5d:%02d mm:ss" $mins $secs && return
    hours=$((mins / 60))
    mins=$((mins - 60 * hours))
    printf "%2d:%02d:%02d hh:mm:ss" $hours $mins $secs
}

#==============================================================================
# Cache Routines
#==============================================================================
#------------------------------------------------------------------------------
# create_cache  type subtype dir
# restore_cache type subtype dir
#
# Each cache is identified by "type-subtype". The purpose of this split is to
# allow the user to turn caching on and off by type although right now the
# only type is "debootstrap".
#
# _cache_() contains common intro code for create_cache() and restore_cache().
#------------------------------------------------------------------------------
create_cache()  { _cache_ create  "$@"; }
force_cache()   { _cache_ force   "$@"; }
restore_cache() { _cache_ restore "$@"; }
was_cached()    { _cache_ was     "$@"; }

_cache_() {
    local ctype=$1; shift
    local type=$1 subtype=$2 dir=$3

    local cache_exclude="^/Build|^/proc/|^/sys/|^/var/cache/apt/archives/"

    echo $dir | grep -q "^$remaster_dir" || fatal "Refusing to cache suspicious directory: $dir"

    case ,$CACHE, in
        *,$type,*) ;;
                *)  say "Skipping cache type $(pq $type)"
                    return 1;;
    esac

    local cache_dir=$remaster_dir/cache
    mkdir -p $cache_dir
    local ext=.cpio.gz
    local name=$type-$subtype
    local file=$cache_dir/$name$ext

    if [[ $ctype = was ]]; then
        test -e $file
        return $?
    fi

    local short
    short=$(short_dir $cache_dir)
    if [[ -n $CACHE_EXPIRE && $CACHE_EXPIRE -gt 0 ]]; then
        #vsay "Find $(pqn $ext) files to expire in $(pq $short)"
        local expire
        expire=$(find $cache_dir -name "*$ext" -ctime +$CACHE_EXPIRE)
        for e in $expire; do
            say "Expire:$bold_co $(basename $e $ext)$nc"
        done
        [[ -n $expire ]] && YES_no "Expire these files" \
            && find $cache_dir -name "*$ext" -ctime +$CACHE_EXPIRE -delete
    fi

    case $ctype in
    restore)
        test -e $file || return 1
        say "Found cache $(pq $name$ext)"
        YES_no "Restore from this cache" || return 1

        if [[ -d "$dir" && $(find "$dir" -mindepth 1 -maxdepth 1 -print -quit 2>/dev/null) ]]; then
            say "Clear out existing files"
            find "$dir" -mindepth 1 -delete
        fi
        mkdir -p $dir

        say "Restore $(pq $type $subtype) from cache"
        start_timer
        (cd $dir && gunzip -c $file | $SUDO cpio -idum --quiet)
        end_timer "Restore cache"
        say "Restored $(pqn $(du_size $dir)) bytes of data"
        ;;

    create|force)

        say "Create cache of $(pq $type $subtype)"

        if test -e $file; then
            [[ $ctype = create ]] && return 1
            YES_no "Overwrite exiting cache file?" || return 1
        fi

        test -d $dir || fatal "Can't cache a non-existent directory: $dir"
        mkdir -p $cache_dir

        # This prevents us from prompting for the password two
        # time simultaneously inside the parens below.
        $SUDO echo >/dev/null
        start_timer

        (cd $dir && $SUDO find . -depth | grep -vE "$cache_exclude" \
            | $SUDO cpio -oa -H newc --quiet | $GZIP -3) > $file

        end_timer "Create cache"
        ;;
    *)
        fatal "Unknown _cache_ type: $ctype"
        ;;
    esac
    return 0
}

#==============================================================================
# Printing, Logging and yes/no question
#==============================================================================

vexit()  { _say_ "${bold_co}Exit:$nc $*";         my_exit 0 ;}
warn()   { _say_ "${bold_co}Warning:$bold_co $*$nc"         ;}
say2()   { echo; say "$*"                                   ;}
say()    { _say_ "$text_co$*$nc"                            ;}
psay()   { say "$(plural "$@")"                             ;}
yell()   { _say_ "$bold_co$*$nc"                            ;}
vsay()   { [[ -n $verbose_mode ]] && say "$*"               ;}
nqsay()  { [[ -z $quiet_mode ]] && say "$@"                 ;}

pqh()    { echo "$text_co$*$high_co"  ;}
pqnh()   { echo "$num_co$*$high_co"   ;}
pq()     { echo "$high_co$*$text_co"  ;}
pqn()    { echo  "$num_co$*$text_co"  ;}
pqw()    { echo "$text_co$*$bold_co"  ;}
pqnw()   { echo  "$num_co$*$bold_co"  ;}

say_fmt() {
    local lab=$1 val=$2
    local fmt
    fmt="%15s:$(pqn %5s) meg\n"
    say "$(printf "$fmt" "$lab" "$val")"
}

say_in() {
    local color=$1  msg=$2
    _say_ "$(echo "$msg" | sed -e "s/^/$color/" -e "s/$/$nc/")"
}

_say_() {
    echo -e "$*"
    [[ -n $log_file ]] && echo -e "$*" >> $log_file
}

error()  {
    _say_ "${err_co}Error:$bold_co $*$nc"

    YES_no "Ignore this error" || my_exit 1
    say "Error ignored"
    return 0
}

fatal()  {
    _say_ "${err_co}Fatal Error:$bold_co $*$nc"
    my_exit 1
}


#------------------------------------------------------------------------------
# echo a command to the sceeen and the log file then run it
#------------------------------------------------------------------------------
cmd() {
    _say_ " > $*"
    "$@"
}
#------------------------------------------------------------------------------
# plural cnt string
# Do simple substition on <string> to match the <cnt>. May need more entries
# but the current set suffices for now.
#------------------------------------------------------------------------------
plural() {
    local n=$1 str=$2
    case $n in
        1) local s='' ies=y   are=is   were=was  es=;;
        *) local s=s  ies=ies are=are  were=were es=es;;
    esac
    echo "$str" | sed -e "s/%s\>/$s/g" -e "s/%ies\>/$ies/g" \
        -e "s/%are\>/$are/g" -e "s/%n\>/$n/g" -e "s/%were\>/$were/g" \
        -e "s/%es\>/$es/g" -e "s/%3d\>/$(printf "%3d" $n)/g"
}

#------------------------------------------------------------------------------
# A collection of routines to ask Yes/No questions. The default is in upper
# case. The *_loud versions ignore quiet_mode.
#------------------------------------------------------------------------------
YES_no()      { _yes_no_  0  0  "(Y/n)"  "$1"; }
yes_NO()      { _yes_no_  1  1  "(y/N)"  "$1"; }
yes_no_loud() { _yes_no_ -1 -1 "((y/n))" "$1"; }
YES_no_loud() { _yes_no_ -1  0 "((Y/n))" "$1"; }
yes_NO_loud() { _yes_no_ -1  1 "((y/N))" "$1"; }

#------------------------------------------------------------------------------
# _yes_no_ quiet_ret default_ret yn_prompt prompt
# Immediately return quiet_ret if it is greater or equal to zero and we are in
# quiet_mode. Return default_ret if the empty string is given and default_ret
# is greater than or equal to zero. Otherwise return true on yes and false on
# no.
#------------------------------------------------------------------------------
_yes_no_() {
    local ans quiet_ret=$1 def_ret=$2 yn=$3 prompt=$4

    [[ -n $quiet_mode && $quiet_ret -ge 0 ]] && return $quiet_ret

    while true; do
        echo -ne "$text_co$prompt$prompt_co $yn?$nc "
        read ans
        case x$ans in
            x[Yy]*) return 0;;
            x[Nn]*) return 1;;
                 x) [[ $def_ret -ge 0 ]] && return $def_ret;;
        esac

        [[  -z $ans ]] && echo -n 'You must answer "y" or "n".  '
        [[  -n $ans ]] && echo "bad answer: <$ans>"
        echo "Please try again"
    done
}

#==============================================================================
# Usage Routines
#==============================================================================
show_stages() {
    echo -e "${bold_co}The stages of processsing:$nc\n"
    while read num title; do
        printf " $bold_co%2d$nc. $text_co%s$nc\n" "$num" "$title"
    done << Extract_Stages
$(sed -r -n "s/^\s*enter_stage\s*([0-9]+)\s*\"[!]?([^\"]+)\".*/\1 \2/p" $0)
Extract_Stages

    cat << Stages_Blurb

There is limited control over running stages with the following environment
variables. Each variable can be set to a comma delimited list of stages
it applies to. Put "a" or "all" in a list to have it apply to all stages.

${text_co}  ASK_STAGE$nc Ask before running stage
${text_co} EXIT_STAGE$nc Exit right *before* running stage
${text_co} SKIP_STAGE$nc do not run stage

Stages_Blurb
}

show_parts() {
    echo -e "${bold_co}The parts within stage-4:$nc\n"
    while read num title; do
        printf " $bold_co%2d$nc. $text_co%s$nc\n" "$num" "$title"
    done << Extract_Parts
$(sed -r -n 's=^\s.*do_part\s+([0-9]+)\s+"[!]?([^"]+)".*=\1 \2=p' $0)
Extract_Parts

    cat << Parts_Blurb

The running of each part can be controled by the following environment
variables. Each variable can be set to a comma delimited list of parts
it applies to. Put "a" or "all" in a list to have it apply to all parts.
Ranges are allowed such as in SKIP_PART=1-7,9,11

${text_co}  ASK_PART$nc Ask before doing part
${text_co} EXIT_PART$nc Exit *after* doing part
${text_co}  RUN_PART$nc Do the part even if it is in SKIP_PART
${text_co}SHELL_PART$nc Open a shell before doing the part
${text_co} SKIP_PART$nc Skip doing the part
${text_co} TEST_PART$nc If this list contains a digit then only do
           the parts on the list and skip all others
Parts_Blurb
}

expand_parts() {
    local val var
    for var; do
        eval val=\$$var
        [[ $val =~ - ]] || continue
        val=$(expand_range $val)
        eval $var=\$val
    done
}

expand_range() {
    local range
    range="$(_expand_range_ "$1")"
    echo "${range// /,}"
}

_expand_range_() {
    for p in ${1//,/ }; do
        if ! echo $p | grep -Eq "^[0-9]+-[0-9]+$"; then
            echo "$p"
            continue
        fi
        local first last
        first=$(echo $p | cut -d- -f1)
        last=$(echo $p | cut -d- -f2)
        seq $first $last
    done
}

#==============================================================================
# Routines used in stage-0
#==============================================================================
#------------------------------------------------------------------------------
# choose prompt var_name choice-1 choice-2 ...
# Multiple choice. If the variable is already defined (usually in the DEFAULTS
# file) then we do nothing. If the variable is in the DEFAULTS file then offer
# to update the default in DEFAULTS.
#------------------------------------------------------------------------------
choose() {
    local value title=$1 var=$2;
    shift 2;

    eval value=\$$var
    [[ -n $value && -z $reset_mode ]] && return

    local prompt="${err_co}Enter a number$prompt_co>$nc "
    echo
    [[ -n $value ]] && say "Current $(pq $title) default: $(pq $value)"

    my_select "Select $title:" "$prompt" value "$@"

    # Strip first " (" and all that follows it (for ENABLE_LOCALES)
    # Quite a kludge but it seems to work okay.
    value=${value%% (*}
    eval $var=\$value

    update_default_file $var "$value"
}

my_select() {
    local title=$1 prompt=$2 var=$3;
    shift 3

    local data display lab cnt=0
    for lab; do
        cnt=$((cnt+1))
        data="${data}$cnt:$lab\n"
        display="${display}$(printf "%2d) %s" $cnt "$lab")\n"
    done

    local val input
    while [[ -z $val ]]; do

        printf "$bold_co$title$nc\n"
        printf "$display" | column | sed -r "s/(^|\t)( ?[0-9]+)/\t$green\2$nc/g"
        printf "$prompt"

        read input
        if [[ -z $input ]] || ! echo "$input" | grep -q "^[0-9]\+$"; then
            echo "You must input a number"
            continue
        fi

        val=$(echo -e "$data" | sed -n "s/^$input://p")

        if [[ -z $val ]]; then
            echo  "Input out of range"
            continue
        fi

        eval $var=\"$val\"
        break
    done
}

#------------------------------------------------------------------------------
# update_default var_name
#------------------------------------------------------------------------------
update_default() {
    local value var=$1
    eval value=\$$var
    local orig_val=$value
    [[ -n $value && -z $reset_mode ]] && return
    echo -e "\n${text_co}Update default $(pq $var): $orig_val$nc"
    [[ -n $orig_val ]] && YES_no "Use current default" && return

    while true; do
        echo -n "Enter new default> "
        read value
        echo
        : ${value:=$orig_val}
        if echo "$value" | grep -q '["\\$]'; then
            warn "Removing [\"\\\$] characters"
            # Remove all occurrences of " \ $
            value=${value//['"\$']/}
        fi
        if [[ -z $value ]]; then
            echo "Empty values are not allowed without an existing default."
            continue
        fi
        YES_no "Is \"$(pq "$value")\" correct" && break
    done
    [[ $value != "$orig_val" ]] && update_default_file $var "$value"
}


update_default_file() {
    local file  short var=$1  value=$2

    for file in $(reverse $all_defaults); do
        grep -q "^\s*$var=" $file || continue
        short=$(short_dir $file)
        #YES_no "\nDo you want to save $var ($(pq "$value")) in $(pq $short)" || return
        sed -r -i "s/^(\s*$var=).*/\1\"$value\"/" $file
        say "Saved $(pq "$var=\"$value\"") in file $(pq $short)"
        break
    done
}

reverse() {
    local x final
    for x; do
        final="$x $final"
    done
    echo "$final"
}

load_defaults() {
    local file short
    for file in $all_defaults; do
        short=$(short_dir $file)
        [[ -r $file ]] || fatal "No $(pqw $short) file found."
        source $file
    done
}

pick_prog() {
    local prog found var=$1
    shift
    eval $var=
    for prog; do
        which $prog &>/dev/null || continue
        eval $var=\$prog
        found=true
        break
    done
    [[ -n $found ]] || error "Could not find any of these programs: $(pqw $*)"
}

select_theme() {
    local themes dir
    for dir in "$theme_dir"/*; do
        [[ -d $dir ]] && themes="$themes $(basename $dir)"
    done

    [[ -n $themes ]] || return
    yes_NO_loud "Do you want to set a theme" || return
    choose "Select a theme" THEME $themes
}

check_theme_dir() {
    local theme=${1:-$THEME}
    [[ -z $theme || $theme = none ]] && return
    [[ -d $theme_dir/$THEME ]] \
        || error "The theme directory $(pqw sort_dir $theme_dir/$THEME) does not exist"

}

#==============================================================================
# Overall Flow Control
#==============================================================================
#------------------------------------------------------------------------------
# clear_outputs [stop_stage]
# Clear all the output files. If there is a work directory available, move
# them there, otherwise, erase them. Prompt before doing either. If we are
# in pretend_mode then say what would happen without doing anything.
# If stop_stage is provided then we stop after clearing that stage. Since
# we work in reverse order, this implements a "redo" feature.
#
# Return failure only if user says no to clearing files.
#------------------------------------------------------------------------------
clear_outputs() {
    local names files stop=${1:-0} pretend=$2 delete=$3
    for i in $(reverse $all_stages); do
        [[ $i -lt $stop ]] && break
        local name=stage-$i.out
        local file=$output_dir/$name
        [[ -f $file ]] || continue
        names="$names$name\n"
        files="$files $file"
    done
    local col_names
    col_names=$(echo -e "$names" | sort | column -c 78 | expand \
        | sed -e "s/^/$high_co/" -e "s/$/$nc/")

    [[ -n $files ]] || return 0

    if [[ -n $pretend ]]; then
        echo -e "$ME would clear:\n$col_names\n"
        return 0

    elif [[ -n $delete ]]; then
        rm -f $files
        return 0

    else
        nqsay "Output files to be cleared:\n$col_names"

        YES_no "Remove these output files" || return 1

        if [[ -n $work_dir && -d $work_dir ]]; then
            #nqsay "Save:\n$col_names"
            local save_out=$work_dir/Output
            mkdir -p $save_out
            mv -f $files $save_out/
        else
            #nqsay "Delete:\n$col_names"
            rm -f $files
        fi
    fi
    return 0
}

my_exit() {
    local ret=${1:-0}
    echo $ret > $exit_file
    exit $ret
}

#------------------------------------------------------------------------------
# do_pretend
# Report what the next stage to work on would be. Also display the name of
# the stage and the global variables (if appropriate). BUG: there are cases
# where the globals aren't 100% accurate if redo_mode or start_from are used.
#------------------------------------------------------------------------------
do_pretend() {
    #[[ -n $redo_mode && $stage -gt 0 ]] && stage=$((stage - 1))
    #[[ -n $start_from && $stage -gt $start_from ]] && stage=$start_from

    echo "$ME would next do stage: $bold_co$stage$nc"

    local stage_info
    stage_info=$(grep -m 1 "^\s\+enter_stage\s\+$stage" $0\
        | sed -r "s/^\s*enter_stage\s*$stage\s*\"[!]?([^\"]+)\".*/    \1/")

    [[ -n $stage_info ]] && echo -e "$text_co$stage_info$nc"

    #[[ $stage -lt 1 || -n $quiet_mode ]] && return 0
    if [[ -z $quiet_mode ]]; then
        echo -e "\nUsing this information:"
        echo
        pretty_output $stage
    fi

    if [[ $stage -gt 0 ]]; then
        echo
        do_one_stat
    fi
    return 0
}

do_stats() {
    local flavs="mx32 mx64 mxahs mxkde"
    is_antiX && flavs="core base full"
    for FLAV in $flavs; do
        ISO_RESPIN_OF=$FLAV
        yell "\n$FLAV$high_co:"
        do_one_stat
    done

    local regex="core|base|full"
    ! is_antiX && regex="$regex|mx32|mx64|mxahs|mxkd"
    for FLAV in $(flavour_list | grep -Ev "^($regex)$"); do
        for ISO_RESPIN_OF in core full; do
            yell "\n$FLAV/$ISO_RESPIN_OF$high_co:"
            do_one_stat
        done
    done
    _say_
    exit
}

do_one_stat() {
    if [[ -n $verbose_mode ]]; then
        gather_say exclude-bootstrap  "    $(pqn %3d) excluded (bootstrap) package%s"
        gather_say exclude-chroot     "    $(pqn %3d) excluded (chroot)    package%s"
        gather_say basic-package      "    $(pqn %3d) basic                package%s"
        gather_say pesky-package      "    $(pqn %3d) pesky                package%s"
        gather_say package            "    $(pqn %3d) antiX                package%s"
        gather_say remove             "    $(pqn %3d) remove               package%s"
        gather_say add                "    $(pqn %3d) add                  package%s"
        gather_say reinstall          "    $(pqn %3d) reinstall            package%s"
    else
        gather_say package            "    $(pqn %3d) antiX                package%s"
    fi
    local needed=$(((TMPFS_SIZE * $(gather_cnt package))/ 10 ))
    say "$(printf "size of tmps: $(pqn %6d) meg\n" $needed)"
}

#------------------------------------------------------------------------------
# global_names
# All the names defined in the DEFAULTS file and the stage-?.out files.
#------------------------------------------------------------------------------
global_names() {
    local stage=${1:-$stage}
    local prev=$((stage - 1))

    # Gather input files
    local files=$normal_defaults
    [[ -n $verbose_mode ]] && files=$all_defaults

    # Gather output files
    local s file
    for s in $(seq 0 $prev); do
        file=$output_dir/stage-$s.out
        [[ -e $file ]] && files="$files $file"
    done

    cat $files 2>/dev/null | sed -n -r "s/^\s*([a-zA-Z_]+)=.*/\1/p" | sort -u
}

#------------------------------------------------------------------------------
# pretty_output
# List names and values of all the globals in DEFAULTS and stage-?.out files
# formated for humans to easily read.
#------------------------------------------------------------------------------
pretty_output() {
    local name value
    for name in $(global_names "$@"); do
        eval value=\"\$$name\"
        printf "$pretty_fmt" "$name" "$value"
    done
}

#==============================================================================
# Outer Utilities
#==============================================================================
#------------------------------------------------------------------------------
# on_exit
# Used in a trap. Make sure we umount the chroot bind mounts and clear the
# window title if it was set.
#------------------------------------------------------------------------------
on_exit() {
    test -z $UMOUNT_ERRORS && umount_chroot

    [[ -n $exit_file ]] && rm -f $exit_file

    #kill_children
    clear_pids

    test -n $DID_WINDOW_TITLE &&  echo -ne "\e]0;\a"

    et=$((-MAIN_T + $(date +%s)))
    if test $et -ge 30; then
    #if [[ -n $STAGE_1_T && -n $STAGE_6_T ]]; then
        _end_timer_ MAIN_T "$ME $ARCH $FLAV"
    fi
    #else
    if [[ -r $sign_off_file ]]; then
        SIGN_OFF=$(cat $sign_off_file 2>/dev/null)
        rm -f $sign_off_file
    fi
    _say_ "$SIGN_OFF"
    #fi
}

#------------------------------------------------------------------------------
# clear_pids
# Kill all our background processes. Currently there is only one.
#------------------------------------------------------------------------------
clear_pids() {
    for name in TAIL_PID_1 TAIL_PID_2; do
        eval local pid=\$$name
        unset   $name
        test -z $pid && continue
        disown  $pid 2>/dev/null
        kill    $pid 2>/dev/null
    done
}

kill_children() {
    disown $(pgrep -P $$) 2>/dev/null
    pkill -P $$           2>/dev/null
}

#------------------------------------------------------------------------------
# require_programs
# Make sure all these programs are on *root's* path.
#------------------------------------------------------------------------------
require_programs() {
    vsay "Check for required programs: $(pq "$@")"
    local prog missing

    for prog; do
        PATH=$root_path which $prog >/dev/null 2>&1 || missing="$missing $prog"
    done
    [[ -n $missing ]] && error "Missing these required programs: $(pqw $missing)"
}

#==============================================================================
# Template Routines
#==============================================================================
#------------------------------------------------------------------------------
# gather $file-name
# Collect all the lines in files in the Template from "all", from the specific
# flavour and from any -AND- directory contain $FLAV. Sort them and make sure
# they are all unique. Primarily used for creating a package.list. Commented
# lines and lines without a letter or digit are ignored. Trailing comments are
# also ignored.
#------------------------------------------------------------------------------

gather() { _gather_ "$@" | sort -u; }

_gather_() {
    local file=$1.list base=${2:-$template}

    for dir in $(flav_dirs); do
        test -r $dir/$file || continue
        sed '/^\s*#/d; s/\s*#.*//' $dir/$file | grep '[a-zA-Z0-9]'
    done
}

gather_cnt() { gather "$@" | wc -l ;}

gather_any() {
    [[ $(gather_cnt "$@") -ge 1 ]]
    return $?
}

gather_say() {
    local file=$1 msg=$2 cnt
    cnt=$(gather_cnt $file)
    psay $cnt "$msg"
}

#------------------------------------------------------------------------------
# gather_join file-name
# Just like gather() but we output a single line with comma separators.
#------------------------------------------------------------------------------
gather_join() {
    local out f
    for f in $(gather $1); do
        out=$out,$f
    done
    echo ${out#,}
}

flav_dirs() {
    local dir=${1:-$template} respin=${2:-$ISO_RESPIN_OF} flav=${3:-$FLAV}

    echo -n $dir/COMMON $dir/$respin-AND-* $dir/*-AND-$respin
    echo " " $dir/*-AND-$respin-AND-* $dir/$flav
}

flavour_list() {
    find "$template" -maxdepth 1 -type d -name '[a-z0-9_]*' -printf '%f\n'
}

#------------------------------------------------------------------------------
# compile_pkg_list package-list exclude-list
#
# Take package-list and remove exclude-list from it
#------------------------------------------------------------------------------
compile_pkg_list() {
    local pkg_list exclude_list result
    pkg_list=$(gather $1)
    exclude_list=$(gather $2)
    for i in $pkg_list ; do
        [[ ! $exclude_list =~ .*$i.* ]] && result="$result $i"
    done
    echo $result
}

#------------------------------------------------------------------------------
# get_template_file [-e] file-name var-name
#
# Fill the variable var-name with the full path to a file in the Template named
# file-name. The priority is first from $FLAV/ then $RESPIN_INHERIT/ and then
# COMMON/. If -e is given then we error out if the file was not found,
# otherwise we leave the variable untouched.
#------------------------------------------------------------------------------
get_template_file() {
    local do_error
    [[ $1 == "-e" ]] && do_error=true && shift

    local flav full file=$1 var=$2

    for flav in $FLAV $RESPIN_INHERIT COMMON; do
        full=$template/$flav/$file
        [[ -r $full ]] || continue
        eval $var=\$full
        return 0
    done

    [[ -n $do_error ]] || return 1
    error "Could not find appropriate $(pqw $name) file in the template"
}

#------------------------------------------------------------------------------
# copy_template_dir [-u] from_dir to_dir
# Copy Template/COMMON/from_dir/* to to_dir/ and then
# copy Template/$FLAV/from_dir/* to to_dir/
# Option -u means copy as normal user.
#
# Option -o means only copy if the original file already exists
#------------------------------------------------------------------------------
copy_template_dir() {
    local sudo=$SUDO  only_overwrite
    [[ $1 == "-u" ]] && sudo="" && shift ;
    [[ $1 == "-o" ]] && only_overwrite=true && shift ;
    local from=$1 dest=$2
    [[ -z $from || -z $dest ]] \
        && fatal "Missing or empty args for copy_template_dir($from, $dest)"

    echo "$dest" | grep -q "^$remaster_dir/work/" \
        || fatal "Suspicious destination in copy_template_dir: $dest"

    $sudo mkdir -p $dest
    for flav in COMMON $RESPIN_INHERIT $FLAV; do
        local dir=$template/$flav/$from
        [[ -d $dir ]] || continue
        if [[ -n $only_overwrite ]]; then
            say "Only overwrite from Template: $(pq $flav/$from)"
            only_overwrite $dir $dest
        else
            say "Copy from Template: $(pq $flav/$from)"
            $sudo cp -R --preserve=link,mode $dir/* $dest/
        fi
    done
}

only_overwrite() {
    local from_dir=$1  dest_dir=$2  from  dest
    while read from; do
        dest=$dest_dir${from#"$from_dir"}
        test -f $dest || continue
        echo "  --> ${dest#"$dest_dir"}"
        $sudo cp -d $from $dest
    done<<Only_Overwrite
$(find $from_dir -type f -o -type l)
Only_Overwrite
}

update_add_remove_lists() {
    local flav dir fname file pkgs date
    date=$(date +"%e %B, %Y")

    for flav in $(flavour_list); do
        dir=$template/$flav
        [[ -d $dir ]] || continue
        for fname in remove.list add.list; do
            file=$dir/$fname
            [[ -e $file ]] || continue
            pkgs=$(grep -v -e "^\s*#" -e "^\s*$" $file | sed 's/\s*#.*//')
            [[ -n $pkgs ]] || next
            cnt=$(echo "$pkgs" | wc -l)
            say "Found $(pqn $cnt) packages in $flav/$fname"
            say_in $high_co "$pkgs"
            #say "$(echo "$pkgs" | sed -e "s/^/    $high_co/" -e "s/$/$nc/")"

            case $fname in
                remove.list)  update_remove_list $file $flav "$pkgs";;
                   add.list)  update_add_list    $file $flav "$pkgs";;
                          *)  error
            esac
            if YES_no "Delete file $(pq $flav/$fname)"; then
                rm -f $file
            fi
        done
    done
    return 0
}


update_remove_list() {
    local targ_dirs file=$1 flav=$2 pkgs=$3

    local comment="#-- REMOVE ($date)"
    if [[ $flav =~ [A-Z] ]]; then
        targ_dirs=$template/$flav
        [[ $flav != "COMMON" ]] && targ_dirs="$targ_dirs $template/COMMON"
    else
        targ_dirs=$(flav_dirs $template $flav $flav)
    fi

    local p tdir tfile tflav short preg regex
    for tdir in $targ_dirs; do
        for tname in package basic-package pesky-packages; do
            tfile=$tdir/$tname.list
            tflav=$(basename $tdir)
            short=$tflav/$tname.list
            [[ -e $tfile ]] || continue
            for p in $pkgs; do
                preg=${p//+/\\+}
                regex="^\s*$preg\s*\\(#\|$\)"
                grep -q "$regex" $tfile || continue
                if YES_no "Remove package $(pq $p) from $short"; then
                    sed -n "/$regex/ s/^\s*\($preg\)\>.*/$comment \1/p" $tfile
                    sed -i "/$regex/ s/^\s*\($preg\)\>.*/$comment \1/"  $tfile
                fi
            done
        done
    done
}

update_add_list() {
    local p targ_dirs  file=$1  flav=$2  pkgs=$3 tfile comment short
    tfile=$(dirname $file)/package.list
    comment="#-- ADD ($date)"
    short=$flav/package.list
    for p in $pkgs; do
        local line
        line=$(printf "%-30s $comment" $p)
        if YES_no "Add package $(pq $p) to $short"; then
            echo "$line"
            echo "$line" >> $tfile
        fi
    done
}

md5sum_file() {
    local dir file
    dir=$(dirname $1)
    file=$(basename $1)
    (cd $dir && md5sum $file > $file.md5)
}

sha256sum_file() {
    local dir file
    dir=$(dirname $1)
    file=$(basename $1)
    (cd $dir && sha256sum $file > $file.sha256)
}

zsyncmake_file() {
    local dir file
    dir=$(dirname $1)
    file=$(basename $1)
    (cd $dir && zsyncmake -e $file)
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
make_real() {
    local file=$1
    test -L $file || return
    local dest
    dest=$(readlink -f $file)
    test -f "$dest" || return
    say "Convert symlink $file to a real file"
    local tmp
    tmp=$(mktemp $file.XXXXXXXX)
    cp $dest $tmp
    mv $tmp $file
}

#------------------------------------------------------------------------------
# Is this an antiX iso?
#------------------------------------------------------------------------------
is_antiX() { [[ $DISTRO_NAME = "antiX" ]] ; return $? ; }

#------------------------------------------------------------------------------
# Distro based check of flavour name
#------------------------------------------------------------------------------
is_distro_flav() {
    local flav=$1
    if is_antiX; then
        case $flav in
            base|core|full) return 0 ;;
        esac
        return 1
    fi
    #
    return 0

    #case $flav in
    #     mx32|mx64|mxahs|mxkde|mxbase64|mxbase32|mxflux32|mxflux64|mxworkbench32|mxworkbench64) return 0 ;;
    #esac
    #return 1
}

#==============================================================================
# One off routines to update the template due to name changes, etc
#==============================================================================
#------------------------------------------------------------------------------
# update_template old-directory new-directory
# Moves old-directory to new-directory in Template after prompting.
#------------------------------------------------------------------------------
update_template() {
    local old=Template/$1 new=Template/$2
    local full_old=$script_dir/$old full_new=$script_dir/$new
    [[ -d $full_old ]] || return
    [[ -d $full_new ]] && return
    echo "Update Template"
    YES_no_loud "Rename $(pq $old) to $(pq $new)" || vexit "Must update to continue"
    mv $full_old $full_new
}

update_template_file() {
    local old=$1 new=$2
    for dir in Template/*; do
        test -d $dir     || continue
        [[ -e $dir/$new ]] && continue
        [[ -e $dir/$old ]] || continue
        say "Moving $(pq $old) to $(pq $new) in Template/$(basename $dir)"
        mv $dir/$old $dir/$new
    done
}

update_list_names() {
    local list
    list=$(find Template -name "*-list")
    [[ -n $list ]] || return;
    echo "Rename *-list file names to *.list"

    YES_no_loud "Rename these files?" || vexit "Must update to continue"

    for old in $list; do
        new=${old/-list/.list}
        [[ -n $new ]] || continue
        echo "Renaming $old"
        mv "$old" "$new"
    done
}

main "$@"

my_exit 0
