#!/bin/bash
# shellcheck disable=SC2317

#==============================================================================
# build-iso: Build antiX liveCD/USB isos from scratch using debootstrap.
#
# Copyright 2012 -- 2024
#     BitJam and anticapitalista for antiX <antiX@operamail.com>
#==============================================================================

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

VERSION="1.99.09"
VERSION_DATE="March 24, 2023"

ME=${0##*/}

UPDATE_SKIP_PART="2-10,14-17,19"
ISO_SKIP_STAGE="2-5,7"

unset ARCH

usage() {
    cat << Usage
Usage: $ME [options] [N]

Build an antiX liveCD/USB iso from scratch using debootstrap.

Options:
    -a --auto           Don't prompt before entering each stage
    -A --AUTO           ... and also clear out most files when done.
    -c --chroot         Enter the chroot environment if it is available
    -C --COLOR=         Color mode: high|low|off. Default is high.
    -d --delete         Delete squashfs dir and stage-?.out files when done
                        without prompting
    -D --DELETE         Also delete entire work directory without prompting
    -e --error-ask      Ask before exiting due to stderr output messages
    -f --fast           Mount chroot directory as tmpfs for speed
    -F --FAST-UMOUNT    List and optionally umount all our tmpfs mounts
    -h --help           Show this help
    -i --iso-only       Only build an iso. Don't create a squashfs file
    -I --INTERACTIVE    Let Debian ask config questions inside the chroot
    -j --jbb            Suppress voluminous output
    -m --manual         Enter chroot if the automatic chroot stage fails
    -n --no-error-check Don't do error checking on stderr output
    -N --NO-ERROR-LOG   Also, don't log or highlight errors on stderr
    -p --pretend        Show what would be done next but do nothing
    -q --quiet          Ask fewer questions (and print less in --pretend mode)
    -r --reset          Update all default variables in stage 0
    -s --stats          Display the number of packages that would be installed
    -S --SAVE           Save the squashfs directory in the cache
    -u --update         Skip most parts in chroot stage preceding add and remove
    -U --UPDATE         Merge add.list and remove.list into the other lists
    -V --VERBOSE        Print even more than we already do
    -v --version        Print version info and exit
    --lz4               Override default compression scheme with lz4
    --user-default      Specify a defaults file, must be present in Input folder
    --zstd              Override default compression scheme with zstd
    --show-stages       Show the stages of processing
    --show-parts        Show parts of stage-$chroot_stage and how to control them
    -0 -- -8            Start over from stage N.
    --stop5				Stop process at Stage 5 (cleanup)
    --stop8				Stop process at Stage 8 (iso generation)

Short options stack: -up0 == -u -p -0 == --update --pretend -0

Optional argument:
    N                 Start over from stage N (same as -N).

Usage
    exit 0
}

# Output from start_main() does not get vlogged
main() {
    unset UMOUNT_ERRORS
    MAIN_T=$EPOCHSECONDS

    local firefox_prefs="/etc/skel/.mozilla/firefox/*/prefs.js"

    local all_stages="0 1 2 3 4 5 6 7 8 9"

    local chroot_stage=4

    local stage output_file
    local manual_mode pretend_mode auto_mode chroot_mode delete_mode delete_all
    local quiet_mode start_from reset_mode iso_only full_auto update_mode UPDATE_mode
    local show_parts show_stages interactive color_mode verbose_mode stats_mode
    local no_log_errors no_check_errors disable_errors do_fast check_tmpfs
    local save_mode jbb_mode

    local script_dir
    script_dir=$(dirname "$(readlink -f "$0")")
    local template="$script_dir/Template"
    local tools="$script_dir/Tools"
    local output_dir="$script_dir/Output"
    local input_dir="$script_dir/Input"
    local remaster_dir
    remaster_dir=$(readlink -f "$script_dir"/Remaster)
    local iso_file_dir="$remaster_dir/iso-files"
    local deb_cache_dir="$remaster_dir/deb-cache/archives"
    local manual_selections=manual-selections
    local exit_file="$output_dir/MUST-EXIT"
    local sign_off_file="$output_dir/SIGN-OFF"

    local first_time_file="$input_dir/first-time"
    local did_stage_file="$output_dir/did-stage"
    local log_file="$output_dir/$ME.log"
    local err_file="$output_dir/$ME.err"
    local make_xinitrc=/usr/share/antiX/lib/make-xinitrc

    # local live_files_list=$input_dir/live-files.list
    local strict_regex_file="$input_dir/strict-exceptions.regex"
    local lax_regex_file="$input_dir/lax-errors.regex"
    local regex_files="$lax_regex_file $strict_regex_file"
    local theme_dir="$script_dir/Themes"
    local root_path="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/opt/bin"

    local part_env="ASK_PART EXIT_PART RUN_PART SHELL_PART SKIP_PART TEST_PART"
    local stage_env="ASK_STAGE EXIT_STAGE SKIP_STAGE"

    local build_dir="/Build"
    local partial_name="PARTIAL"
    local partial_file="$build_dir/$partial_name"
    local seed_fname="random-seed"
    local user_defaults apt_yes
    # local initrd_encrypt

    local short_stack="aAcCdDefFhiIjmnNpqrsuUvV0-8"

    local arg val ARGS
    ARGS="$*"

    while (( $# > 0 )) && [[ $1 =~ ^- ]]; do
        arg=${1#-}; shift

        # Unstack single-letter options
        case $arg in
            [$short_stack][$short_stack]*)
                if echo "$arg" | grep -q "^[$short_stack]\+$"; then
                    # shellcheck disable=SC2046
                    set -- $(echo "$arg" | sed -r 's/([a-zA-Z])/ -\1 /g') "$@"
                    continue
                fi;;
        esac

        # Deal with all options that take a parameter
        case $arg in
          -color|C) (( $# < 1 )) && fatal "Expected a parameter after: $(pqw -$arg)"
                    val=$1
                    [[ $val =~ ^- ]] \
                        && fatal "Suspicious argument after -$arg: $(pqw "$val")"

                    shift         ;;
    -user-default)  (( $# < 1 )) && fatal "Expected a parameter after: $(pqw -$arg)"
                    val=$1
                    # Use basename to allow both "filename" and "Input/filename" formats
                    val=$(basename "$val")
                    user_defaults="$input_dir/$val"
                    [[ ! -e "$user_defaults" ]] \
                        && fatal "Default file not found -$arg: $(pqw "$val")"

                    shift         ;;
              *=*)  val=${arg#*=} ;;
                *)  val="???"     ;;
        esac

        case $arg in
            -auto|a)      auto_mode=true ; apt_yes="-y"         ;;
            -AUTO|A)      auto_mode=true ; full_auto=true ; apt_yes="-y" ;;
          -chroot|c)    chroot_mode=true                        ;;
       -color=*|C=*)     color_mode=$val                        ;;
           -COLOR|C)     color_mode=$val                        ;;
          -delete|d)    delete_mode=true                        ;;
          -DELETE|D)    delete_mode=true ; delete_all=true      ;;
       -error-ask|e)     ask_errors=true                        ;;
            -fast|f)        do_fast=true                        ;;
     -FAST-UMOUNT|F)    check_tmpfs=true                        ;;
            -help|h)   usage                                    ;;
        -iso-only|i)       iso_only=true                        ;;
     -INTERACTIVE|I)    interactive=true                        ;;
             -jbb|j)       jbb_mode=true                        ;;
          -manual|m)    manual_mode=true                        ;;
  -no-error-check|n) disable_errors=true                        ;;
    -NO-ERROR-LOG|N)  no_log_errors=true ; disable_errors=true  ;;
         -pretend|p)   pretend_mode=true                        ;;
           -quiet|q)     quiet_mode=true                        ;;
           -reset|r)     reset_mode=true                        ;;
           -stats|s)     stats_mode=true                        ;;
            -SAVE|S)      save_mode=true                        ;;
        -show-parts)     show_parts=true                        ;;
       -show-stages)    show_stages=true                        ;;
          -update|u)    update_mode=true                        ;;
          -UPDATE|U)    UPDATE_mode=true                        ;;
      -user-default)                                            ;;
         -VERBOSE|V)   verbose_mode=true                        ;;
               -lz4)   lz4_override=true                        ;;
              -zstd)  zstd_override=true                        ;;
             -stop5)         stop_5=true                        ;;
             -stop8)         stop_8=true                        ;;

              [0-8]) [[ $start_from ]] && fatal "Can only set starting stage once"
                     start_from=$arg ;;

         -version|v) echo "$ME version $VERSION ($VERSION_DATE)"; exit ;;
                  *) fatal "Unknown parameter -$arg" ;;
        esac
    done

    is_antiX && apt_yes=

    if (( $# == 1 )) && [[ -z $start_from ]]; then
        arg=$1; shift
        case $arg in
            [0-8])  start_from=$arg ;;
                *)  fatal "Bad stage argument: $arg. Must be [0-8]."
        esac
    fi

    if [[ -n $update_mode ]]; then
        : "${start_from:=$((chroot_stage - 1))}"
        SKIP_PART="$SKIP_PART${SKIP_PART:+,}$UPDATE_SKIP_PART"
    fi

    [[ -n $reset_mode ]] && : "${start_from:=0}"
    [[ -n $iso_only   ]] && SKIP_STAGE="$SKIP_STAGE${SKIP_STAGE:+,}$ISO_SKIP_STAGE"

    case $color_mode in
     high|hi|"") color_mode="high" ;;
         low|lo) color_mode="low"  ;;
            off)                   ;;
              *) fatal "Bad --color operand: $color_mode" ;;
    esac

    local black blue green cyan red purple brown lt_gray dk_gray lt_blue
    local lt_green lt_cyan lt_red magenta yellow white rev_red nc
    local  text_co       bold_co   err_co
    local   num_co     prompt_co  time_co
    local  high_co

    # shellcheck disable=SC2034
    set_colors() {
          black=$'\x1B[0;30m';     blue=$'\x1B[0;34m';      green=$'\x1B[0;32m';
           cyan=$'\x1B[0;36m';      red=$'\x1B[0;31m';     purple=$'\x1B[0;35m';
          brown=$'\x1B[0;33m';  lt_gray=$'\x1B[0;37m';    dk_gray=$'\x1B[1;30m';
        lt_blue=$'\x1B[1;34m'; lt_green=$'\x1B[1;32m';    lt_cyan=$'\x1B[1;36m';
         lt_red=$'\x1B[1;31m';  magenta=$'\x1B[1;35m';     yellow=$'\x1B[1;33m';
          white=$'\x1B[1;37m';  rev_red=$'\x1B[0;7;31m';       nc=$'\x1B[0m';
    }

    if [[ $color_mode != "off" ]]; then
        set_colors
    fi

    case $color_mode in
        high) text_co=$lt_cyan;    bold_co=$yellow;     err_co=$lt_red;
               num_co=$magenta;  prompt_co=$lt_green;  time_co=$cyan;
              high_co=$white; ;;

         low) text_co=$nc;         bold_co=$lt_blue;    err_co=$red;
               num_co=$purple;   prompt_co=$green;     time_co=$cyan;
              high_co=$cyan; ;;
    esac

    [[ -n $pretend_mode ]] || SIGN_OFF="${bold_co}Quit$text_co $ME$nc"

    local pretty_fmt="%15s: $text_co%s$nc\n"

    (( $# > 0 ))           && fatal "Extra command line parameters: $(pqw "$@")"
    [[ -z $script_dir ]]     && fatal "No script_dir!"
    [[ $script_dir = "/" ]]  && fatal "script_dir can't be root dir!"
    [[ -n $show_stages ]]    && show_stages
    [[ -n $show_parts  ]]    && show_parts

    SUDO=sudo
    (( UID == 0 )) && SUDO=

    [[ -n $show_parts || -n $show_stages ]] && exit

    local normal_defaults="$input_dir/defaults $input_dir/defaults-local"
    local all_defaults="$input_dir/defaults-system $normal_defaults"

    if [[ -n $user_defaults ]]; then
        local normal_defaults="$user_defaults $input_dir/defaults-local"
        local all_defaults="$input_dir/defaults-system $normal_defaults"
    fi

    load_defaults

    trap on_exit       EXIT
    trap "echo; exit"  INT

    if [[ -n $pretend_mode || -n $chroot_mode || -n $stats_mode ]]; then
        log_file=/dev/null
    else
        mkdir -p "$(dirname "$log_file")"
    fi

    if [[ -n $check_tmpfs ]]; then
        check_all_tmpfs && exit
        vexit "No tmpfs mounts were found"
    fi

    [[ "$script_dir" == "$build_dir" ]] && no_log_errors=true

    {
        printf "\n$bold_co%63s$nc\n" "" | sed 's/ /-/g'
        echo -e "$ME $ARGS"
        echo -e "  version: $VERSION ($VERSION_DATE)"
        echo -e "  started: $(date)"
        echo -e "directory: $script_dir\n"
    } >> "$log_file"

    # Always start out with a clean slate
    rm -f "$exit_file" "$sign_off_file"

    update_template_file basic-applications.list basic-package.list
    update_template_file pesky-packages.list     pesky-package.list

    [[ -n $update_mode ]] && say "update mode: skipping parts $(pq "$SKIP_PART")"

    expand_parts $part_env $stage_env

    # Clear out the did-stage file
    : > "$did_stage_file"
    # We only advance to the next stage if the previous stages all completed and wrote
    # stage-N.out output files. These files are also used for passing information on
    # from one stage to the next.
    while true; do

        # Read previous output files and set the stage
        for stage in $all_stages; do
            output_file="$output_dir/stage-$stage.out"
            [[ -r "$output_file" ]] || break
            [[ -n "$start_from" ]] && (( stage == start_from )) && break
            # shellcheck disable=SC1090
            source "$output_file"
        done

        # Variables derived from output files
        local full_distro_name="$DISTRO_NAME-${DISTRO_VERSION}_$ISO_ARCH"
        [[ "$DISTRO_NAME" = antiX ]] && full_distro_name="$full_distro_name-$ISO_FLAV"

        local fancy_name="$full_distro_name $CODE_NAME $RELEASE_DATE"
        local work_name="$DISTRO_NAME-${DISTRO_VERSION}-$ISO_ARCH-$DEBIAN_RELEASE"
        [[ "$DISTRO_NAME" = antiX ]] && work_name="$work_name-$ISO_FLAV"
        local work_dir=$remaster_dir/work/$work_name
        local iso_dir=$work_dir/iso
        local sqfs_dir=$work_dir/squashfs
        local sqfs_output_dir=$sqfs_dir$build_dir/Output
        local sqfs_input_dir=$sqfs_dir$build_dir/Input
        local boot_menu_dir=$sqfs_dir/usr/share/boot-menus

        local initrd_dir=$work_dir/initrd
        local manual_selections_template=$template/COMMON/$manual_selections

        local chroot_cache_opts="chroot $work_name $sqfs_dir"
        local deboot_cache_opts="debootstrap $ARCH-$DEBIAN_RELEASE $sqfs_dir"

        # Do weird modes here after variables are set
        [[ -n $chroot_mode ]] && do_chroot && exit

        if [[ -n $start_from ]]; then
            (( stage < start_from )) \
                && fatal "Only at stage $(pqnw "$stage"). Can't start from stage $(pqnw "$start_from")."

            clear_outputs "$start_from" "$pretend_mode" "$delete_mode" || exit
            start_from=
        fi
        [[ -n $save_mode    ]] && do_save    && exit
        [[ -n $pretend_mode ]] && do_pretend && exit
        [[ -n $stats_mode   ]] && do_stats   && exit
        [[ -n $UPDATE_mode  ]] && update_add_remove_lists && exit

        [[ "$script_dir" == "$build_dir" && "$stage" != "$chroot_stage" ]] \
            && fatal "In chroot environment but stage is $(pqw "$stage")"

        # Set window title (but only in normal modes)
        echo -ne "\e]0;$ME stage:$stage $full_distro_name\a"
        DID_WINDOW_TITLE=true

        if has_word SKIP_STAGE "$stage"; then
            say "Skipping stage $(pqn "$stage")"
            leave_stage notime
            continue
        fi

        # We read in these files every time because they might have been
        # edited inside the stages and the changes don't propagate up to here
        if [[ -z $disable_errors ]]; then
            read_error_regexes
            check_errors_reset
            #say "ERROR_OFFSET=$ERROR_OFFSET"
        fi

        if (( stage != chroot_stage )) && [[ -z $no_log_errors ]]; then

            [[ -e "$exit_file" ]] && exit "$(cat "$exit_file")"

            # The tee and sed only apply to stdrr. Stdout goes right through.
            # This highlights stderr output and stores it in a file which we
            # periodically scan with the check_errors_* routines
            main_case  7>&1 1>&2 2>&7 \
                | tee -a "$err_file" | sed -e "s/^/$red/" -e "s/$/$nc/"

            # The redirects above cause main_case() to launch in a subshell which
            # breaks the "exit" command. This fixes it by using my_exit() which
            # writes $exit_file before exiting
            [[ -e "$exit_file" ]] && exit "$(cat "$exit_file" 2>/dev/null)"

        else
            main_case
        fi

    done
}

main_case() {
    case $stage in
         0) do_stage_0   ;;
         1) do_stage_1   ;;
         2) do_stage_2   ;;
         3) do_stage_3   ;;
         4) do_stage_4   ;;
         5) do_stage_5   ;;
         6) do_stage_6   ;;
         7) do_stage_7   ;;
         8) do_stage_8   ;;
         9) do_stage_9   ;;
         *) fatal "Unknown stage: $stage"
    esac
}

#==============================================================================
# The Ten Stages of Processing
#==============================================================================
#------------------------------------------------------------------------------
# Stage 0 gathers all user input and prepares defaults and directories
#------------------------------------------------------------------------------
do_stage_0() {
    enter_stage 0 "!Gather inputs and set defaults"

    [[ -s "$err_file" && -z "$no_log_errors" ]]  \
        && YES_no "Clear error file $(pq "$ME.err")" && : > "$err_file"

    if [[ -e "$first_time_file" ]]; then
        say    "The input file structure and layout have changed."
        say    "Your are encouraged to run in $(pq --reset) mode to verify input parameters."
        if YES_no "Enter $(pq --reset) mode"; then
            say "Entering $(pq --reset) mode."
            reset_mode=true
        else
            rm -f "$first_time_file"
        fi
    fi

    pick_prog MAKE_ISO $MAKE_ISO_PROGS
    pick_prog GZIP     $GZIP_PROGS

    require_programs chroot debootstrap isohybrid mksquashfs md5sum sudo tee zsync \
        pkill column expand strings iconv unbuffer

    mkdir -p "$output_dir" || my_exit

    # Give user a chance to set up directories the way they want
    if ! [[ -d $remaster_dir ]]; then
        cat << Remaster_Blurb

The "Remaster" directory does not exist. This is where *.iso files,
cache files, and intermediate storage will reside. Think gigabytes.

If you want it to be on a different device then exit now and create
a symlink called "Remaster".

Remaster_Blurb

        YES_no_loud "Shall I create a local \"Remaster\" directory for you" \
            || vexit "Need Remaster symlink or directory to continue"

        mkdir -p "$script_dir/Remaster" || my_exit
    fi

    local name
    for name in DISTRO_NAME DISTRO_VERSION CODE_NAME K_VERSION K_REVISION \
        NEW_HOSTNAME; do
        update_default $name
    done

    load_defaults

    # Fill in default value
    : "${RELEASE_DATE:=$(printf '%(%e %B %Y)T' -1)}"

    choose "local mirror" LOCAL_MIRROR                       \
                us gr au be bg br ch cz de dk ee es "fi" fr  \
                gr hk hr hu ie is it jp kr nl no nz pl pt ro \
                ru se si sk tr tw ua uk us

    choose "Debian release" DEBIAN_RELEASE \
                stable testing unstable bullseye bookworm

    choose "which locales to enable" ENABLE_LOCALES  \
                "Default (about 60)"                 \
                "All (about 400)"                    \
                "Single (the one default locale)"

    choose "arch"     ARCH      i386 amd64
    # shellcheck disable=SC2046
    choose "flavour"  ISO_FLAV  $(flavour_list) core-libre

    K_GNU=
    case $ISO_FLAV in
        *-libre) K_GNU=-gnu
                 FLAV=${ISO_FLAV%-libre} ;;
              *) FLAV=$ISO_FLAV ;;
    esac

    RESPIN_INHERIT=
    if is_distro_flav "$FLAV"; then
        ISO_RESPIN_OF=$FLAV
    else
        choose "flavour to base respin on" ISO_RESPIN_OF full base core

        if [[ -z $(ls "$template/$FLAV") ]] \
            && YES_no "Fill \"$FLAV\" directory from \"$ISO_RESPIN_OF\" ?"; then
            cp "$template/$ISO_RESPIN_OF"/*.list "$template/$FLAV/"
            YES_no "Do you want to stop now to edit your new respin?" \
                && vexit "at user's request"
        fi
        RESPIN_INHERIT=$ISO_RESPIN_OF
    fi

    is_distro_flav "$ISO_RESPIN_OF" || fatal "Invalid flavour to base respin on: $ISO_RESPIN_OF"

    local distro_k_arch=686
    is_antiX && distro_k_arch=486
    case $ARCH in
         i386) K_ARCH=$distro_k_arch   ; ISO_ARCH=386  ;;
        amd64) K_ARCH=amd64            ; ISO_ARCH=x64  ;;
            *) error "Invalid ARCH $(pqw "$ARCH"). Expected $(pqw i386) or $(pqw amd64)". ;;
    esac

    K_NAME=$(echo "$K_TEMPLATE" | sed \
    -e "s/%V/$K_VERSION/"   \
    -e "s/%G/$K_GNU/"       \
    -e "s/%R/$K_REVISION/"  \
    -e "s/%A/$K_ARCH/"      \
    -e "s/%V/$K_VERSION/")

    local $HOST_ARCH
    case $(arch) in
        i386|i486|i686) HOST_ARCH=386 ;;
        x86_64)         HOST_ARCH=x64 ;;
        *) error "Cannot detect Host ARCH" ;;
    esac

    # Kernel wildcard resolution deferred to Stage 4 (after chroot setup)
    if [[ $K_NAME =~ \* ]]; then
        say "Kernel wildcard $(pq "$K_NAME") will be resolved in Stage 4"
    fi

    #$K_VERSION$K_GNU-antix.$K_REVISION-$K_ARCH-smp

    [[ -n $THEME ]] || select_theme

    check_theme_dir "$THEME"

    # repeated code
    remaster_dir=$(readlink -f "$script_dir/Remaster")
    local full_distro_name=$DISTRO_NAME-${DISTRO_VERSION}_$ISO_ARCH
    [[ $DISTRO_NAME = antiX ]] && full_distro_name=$full_distro_name-$ISO_FLAV
    local iso_file=$full_distro_name.iso

    local dir
    for dir in $(flavour_list) COMMON base-AND-full; do
        mkdir -p "$script_dir/Deb/$dir"
    done

    local full_iso_file=$iso_file_dir/$iso_file
    if [[ -e "$full_iso_file" ]]; then
        say "The output file $(pq "Remaster/iso-files/$iso_file") already exists!"
        say "If we continue then it will get over-written."
        YES_no "Continue anyway" || my_exit 0
    fi

    cat << Output > $output_file
ARCH="$ARCH"
DEBIAN_RELEASE="$DEBIAN_RELEASE"
FLAV="$FLAV"
GZIP="$GZIP"
ISO_ARCH="$ISO_ARCH"
ISO_FLAV="$ISO_FLAV"
K_NAME="$K_NAME"
MAKE_ISO="$MAKE_ISO"
RELEASE_DATE="$RELEASE_DATE"
RESPIN_INHERIT="$RESPIN_INHERIT"
THEME="$THEME"
ISO_RESPIN_OF="$ISO_RESPIN_OF"
Output

    say "Ready to begin creation of $(pq "$iso_file")"
    pretty_output $((stage + 1)) >> $log_file

    [[ -e "$first_time_file" ]] && rm -f "$first_time_file"

    if [[ -z $quiet_mode ]]; then
        echo "With:"
        pretty_output $((stage + 1))
        echo
    fi
    do_one_stat
    # shellcheck disable=SC2059
    printf "$pretty_fmt"  REMASTER_DIR  "$remaster_dir"
    # shellcheck disable=SC2059
    printf "$pretty_fmt" "on device"    "$(df "$remaster_dir" | tail -n1 | cut -f1 -d" ")"
}

#------------------------------------------------------------------------------
# Stage 1 creates working directories and symlinks
#------------------------------------------------------------------------------
do_stage_1() {
    enter_stage 1 "Make directories and symlinks"

    convenience_link "$work_dir"   work
    convenience_link "$sqfs_dir"   sqfs
    convenience_link "$iso_dir"    iso
    convenience_link "$initrd_dir" initrd

    $SUDO chown root:root "$sqfs_dir"

    leave_stage notime
}

#------------------------------------------------------------------------------
# Stage 2 runs debootstrap, makes some small adjustmesnt to the fs and also
# handles caching what debootstrap created.
#------------------------------------------------------------------------------
do_stage_2() {
    enter_stage 2 "Run debootstrap"

    [[ $do_fast ]] && mount_tmpfs

    if [[ -d "$sqfs_dir" ]]; then
        say "Clear out existing files ..."
        check_sqfs_dir
        # Convoluted to be safer against deleting entire filesystem
        $SUDO rm -rf "$(dirname "$sqfs_dir")"/squashfs/*
    fi

    if restore_cache $chroot_cache_opts; then
        leave_stage
        return
    fi

    if ! restore_cache $deboot_cache_opts; then

        say "debootstrap for $(pq "$ARCH" "$DEBIAN_RELEASE") from local mirror $(pq "$LOCAL_MIRROR") ..."
        umount_chroot
        mount_deb_cache

        local args cnt exclude_list include_list keyring url
        args="--arch=$ARCH"
        exclude_list=$(gather_join exclude-debootstrap)
        include_list=$(gather_join include-debootstrap)
        cnt=$(echo "$exclude_list" | tr ',' '\n' | wc -l)
        psay $cnt "Exclude $(pqn %n) package%s"
        keyring="$template/$ISO_RESPIN_OF/keyring.gpg"
        [[ -n "$exclude_list" ]] && args="$args --exclude=$exclude_list"
        [[ -n "$include_list" ]] && args="$args --include=$include_list"
        [[ -r "$keyring" ]] && args="$args --keyring=$keyring"
        url="$(eval echo "$MIRROR_URL_TEMPLATE")"

        check_errors_strict
        start_timer
        $SUDO mkdir -p "$sqfs_dir/usr" "$sqfs_dir/etc"
        $SUDO debootstrap $args "$DEBIAN_RELEASE" "$sqfs_dir" "$url"
        end_timer "run debootstrap \"$ARCH\" \"$DEBIAN_RELEASE\""
        check_errors_lax

        ##anticapitalista - remove systemd from 4 files in /etc
        if is_antiX; then
            say "removing systemd from 4 files"
            $SUDO sed -i '/^systemd/d' "$sqfs_dir"/etc/{group,gshadow,passwd,shadow}
            say "de-systemd complete"
        fi

        umount_chroot

        [[ -e "$sqfs_dir/bin/bash" ]] || error "debootstrap failed"
    fi

    report_size "$sqfs_dir"

    create_cache $deboot_cache_opts

    say "Customize live system for antiX"
    $SUDO rm -f "$sqfs_dir/etc/apt/sources.list"
    copy_template_dir squashfs "$sqfs_dir"

    leave_stage
}

#------------------------------------------------------------------------------
# Stage 3 prepares for running the chroot command for either a Bash shell or
# for running stage 4 in the chroot. Much of this functionality is repeated
# when the --chroot option is used so we put most of the work in prep_chroot().
#------------------------------------------------------------------------------
do_stage_3() {
    enter_stage 3 "Prepare chroot"

    check_sqfs_dir

    # We want to run stage N+1 inside the chroot so we need to signal
    # that the current stage is done
    leave_stage notime

    # Save the PARTIAL file from destruction but don't be fooled by older copies
    rm -f "$work_dir/$partial_name"
    [[ -e "$sqfs_dir$partial_file" ]] && cp "$sqfs_dir$partial_file" "$work_dir"

    # Make sure we start over from scratch
    $SUDO rm -rf "$sqfs_dir$build_dir"

    prep_chroot

    # Put saved PARTIAL file back in the build directory
    [[ -e "$work_dir/$partial_name" ]] \
        && $SUDO mv "$work_dir/$partial_name" "$sqfs_dir$partial_file"

    # This stage must fail if the next stage fails
    rm "$output_file"

    # Get realtime log updates from the chroot
    (tail -n 0 -f "$sqfs_output_dir/$ME.log" >> "$log_file") &
    export TAIL_PID_1=$!

    if [[ -z $no_log_errors ]]; then
        touch "$err_file"
        (tail -n 0 -f "$err_file" > "$sqfs_output_dir/$ME.err") &
        export TAIL_PID_2=$!
    fi
    HOST_HOSTNAME=$(hostname)

    local args
    local next_output_file
    next_output_file=$sqfs_output_dir/stage-$((stage + 1)).out

    [[ -n $interactive     ]] && args="--interactive"
    [[ -n $auto_mode       ]] && args="$args --auto"
    [[ -n $quiet_mode      ]] && args="$args --quiet"
    [[ -n $ask_errors      ]] && args="$args --error-ask"
    [[ -n $verbose_mode    ]] && args="$args --VERBOSE"
    [[ $color_mode != high ]] && args="$args --COLOR=$color_mode"
    [[ -n $disable_errors  ]] && args="$args --no-error-check"
    mountpoint -q "$sqfs_dir"   && args="$args --fast"

    check_errors_strict

    say "Run $(pq "$ME") in chroot"
    $SUDO chroot "$sqfs_dir" "$build_dir/$ME" $args

    $SUDO hostname "$HOST_HOSTNAME"

    if [[ ! -e "$next_output_file" && -n "$manual_mode" ]]; then
        say "The buld inside the chroot failed"
        say  "======================================================="
        say  "You are in a chroot environment."
        say  "Use the command $(pq /Build/$ME $args)"
        say  "to continue building"
        say  "Use $(pq exit) or $(pq Ctrl-D) when done"
        say  "======================================================="
        $SUDO chroot "$sqfs_dir" /bin/bash -rcfile "$build_dir/bashrc" 2>&1
        say "Left chroot"
    fi

    check_errors_reset
    clear_pids
    kill_chroot_procs
    umount_chroot

    [[ -e "$next_output_file" ]] || fatal "Build inside chroot failed"

    local chroot_selections=$sqfs_dir$build_dir/$manual_selections
    if [[ -r "$chroot_selections" ]]; then
        say "Update $(pq "$manual_selections") in Template"
        cp "$chroot_selections" "$manual_selections_template"
    fi

    local missing
    for missing in "$sqfs_dir$build_dir"/missing*; do
        [[ -r "$missing" ]] && cp "$missing" "$work_dir"
    done

    cp "$sqfs_output_dir/package-list.out"        "$work_dir"
    cp "$sqfs_input_dir/strict-exceptions.regex"  "$input_dir"
    cp "$sqfs_input_dir/lax-errors.regex"         "$input_dir"
    cp "$next_output_file"                        "$output_dir"

    leave_stage

    report_size "$sqfs_dir"
}

#-----------------------------------------------------------------------------
# Stage 4 is the heart of the program. It runs inside the chroot and does most
# of the tasks needed to convert a debootstrap system into antiX. Each part
# inside here can be controled with the ASK_PART, SKIP_PART, etc environment
# variables.
#------------------------------------------------------------------------------
do_stage_4() {
    enter_stage 4 "!Inside of chroot"
    _say_ "$num_co===============================================================$nc"

    #error-logchecking ASAP so we don't waste user's time
    [[ "$script_dir" == "$build_dir" ]] || fatal "We do not appear to be in a chroot environment"

    [[ -n $K_NAME ]] || error "No K_NAME specified"

    # Resolve kernel wildcard using target repository
    if [[ $K_NAME =~ \* ]] && do_part 1 "Search for complete kernel name"; then
        search_for_k_name
        end_part_strict
    else
        skip_part 1 "Search for complete kernel name"
    fi

    if ! [[ -r $manual_selections_template ]]; then
        say "No $(pq $manual_selections) file found. Forcing $(pq interactive) mode"
        interactive=true
    fi

    if [[ -n $interactive ]]; then
        say "Interactive mode $(pq enabled)"
        if [[ -r "$manual_selections_template" ]] && YES_no_loud "Load current defaults"; then
            say "Set defaults from $(pq "$manual_selections") file"
            debconf-set-selections "$manual_selections_template"
        fi
    else
        say "interactive mode ${num_co}disabled"
        export DEBIAN_FRONTEND=noninteractive
        say "Set defaults from $(pq "$manual_selections") file"
        debconf-set-selections "$manual_selections_template"
    fi

    # Doesn't seem to be needed, it just shows an error that /proc/mounts = /etc/mtab
    # say "Create $(pq /etc/mtab)"
    # grep -v rootfs /proc/mounts > /etc/mtab

    echo $$ > $build_dir/MY-PID

    say "prepend $(pq $build_dir/fake) to PATH"
    PATH=$build_dir/fake:$PATH

    # Read in the ASK_PART, SKIP_PART, etc values from outer program
    [[ -r "$script_dir/ENV_IN" ]] && source "$script_dir/ENV_IN"

    require_programs apt-get

    # Skip PARTIAL file check if we have no stage output files (clean build)
    if [[ ! -f "$script_dir/../Output/stage-1.out" ]] && [[ -s "$partial_file" ]]; then
        rm -f "$partial_file"
        skip_part 0 "Read PARTIAL file to skip parts done (clean build)"
    elif [[ -s "$partial_file" ]]  \
        && do_part 0 "!Read PARTIAL file to skip parts done"; then
        local add_skip
        add_skip=$(join_lines "$partial_file" ",")
        say "have already processed these parts: $(pq "$add_skip")"
        if YES_no "Skip these parts this time"; then
            SKIP_PART="$SKIP_PART${SKIP_PART:+,}$add_skip"
        else
            rm -f "$partial_file"
        fi
    else
        skip_part 0 "Read PARTIAL file to skip parts done"
    fi

    if ! is_antiX; then
        local early_deb
        if ls /*"${ARCH}".deb >/dev/null 2>&1; then
            for early_deb in /*"${ARCH}".deb; do
                [[ -f "$early_deb" ]] || continue
                say "Install arch deb package $(pq "$early_deb")"
                apt-get install "$early_deb"; rm "$early_deb"
            done
        fi
        if ls /*all.deb >/dev/null 2>&1; then
            for early_deb in /*all.deb; do
                say "Install all deb package $(pq "$early_deb")"
                apt-get install "$early_deb"; rm "$early_deb"
            done
        fi
    fi

    # for 64 bit set multiarch
    if [[ $ARCH = "amd64" ]] ; then
        say "Adding multiarch support"
        dpkg --add-architecture i386
    fi

    if do_part 1 "Update repos and do apt-get update"; then
        local list_dir=/etc/apt/sources.list.d
        # Remove non-free repos from -libre flavours
        [[ $ISO_FLAV =~ -libre$ ]] \
            && sed -i -e 's/\<contrib\>//g' -e 's/\<non-free\>//g' $list_dir/debian.list

        apt-get $APT_GET_OPTS update
        end_part_lax
    fi

    if [[ $K_NAME =~ \* ]]; then
        skip_part 2 "Search for complete kernel name (deferred to Stage 4)"
    else
        skip_part 2 "Search for complete kernel name"
    fi

    : "${LOCALE:=en_US.UTF-8}"

    if do_part 3 "!Define locales"; then
        case $ENABLE_LOCALES in
            [Aa]ll) say "Will build $(pq all) locales"
                    sed -i -r "s/^# ([a-z][a-z]([a-z]?_| ISO|\.UTF| UTF))/\1/" /etc/locale.gen;;

        [Dd]efault) say "Will build $(pq default) default locales" ;;

         [Ss]ingle) say "Will build $(pq "$LOCALE") locale"
                    local locale_re=${LOCALE//./\.}
                    sed -i -r -e "s/^([a-z])/# \1/" -e "s/^#\s+($locale_re)/\1/" /etc/locale.gen;;

                 *) error "Bad ENABLE_LOCALES: $ENABLE_LOCALES"
        esac

        local cnt
        cnt=$(grep -c '^[a-zA-Z]' /etc/locale.gen)
        psay "$cnt" "There %are now $(pqn %n) locale%s to generate"
        end_part_lax
    fi

    if gather_any basic-package \
        && do_part 4 "Install basic packages"; then
        install_packages basic-package basic
        end_part_lax
    else
        skip_part 4 "Install basic packages"
    fi

    if do_part 5 "Install kernel & headers"; then
        local kname="linux-image-$K_NAME"
        ! is_antiX && kname="$kname$UNSIGNED"
        apt-get $APT_GET_OPTS install "linux-headers-$K_NAME" "$kname"
        end_part_strict
    fi

    if do_part 6 "Update locales"; then
        : "${LOCALE:=en_US.UTF-8}"
        say "Set default locale to $(pq "$LOCALE")"
        update-locale "LANG=$LOCALE"
        end_part_lax
    fi

    if gather_any pesky-package \
        && do_part 7 "Install pesky packages"; then
        gather_say pesky-package "Install $(pqn %n) pesky package%s"
        for package in $(compile_pkg_list "pesky-package" "exclude-chroot"); do
            # Pre-configure firmware-ipw2x00 to accept license automatically
            if [[ "$package" = "firmware-ipw2x00" ]]; then
                echo 'firmware-ipw2x00 firmware-ipw2x00/license/accepted boolean true' | debconf-set-selections
            fi
            DEBIAN_FRONTEND=dialog apt-get install $apt_yes "$package"
            if [[ "$package" = "systemd-init-diversity" ]]; then
            	echo "systemd-init-diversity installed, remove systemd-sysv"
            	apt-get remove --allow-remove-essential $apt_yes systemd-sysv
            fi
        done
        end_part_lax
    else
        skip_part 7 "Install pesky packages"
    fi

    if gather_any package \
        && do_part 8 "Install antiX packages"; then
        install_packages package $FLAV
        end_part_lax

    else
        skip_part 8 "Install antiX packages"
    fi

    #say_in $high_co "$(list_newer_procs)"

    show_tmpfs_and_mem

    if do_part 9 "Run first apt-get -f $apt_yes install"; then
        apt-get update && apt-get $APT_GET_OPTS dist-upgrade
        apt-get -f install
        end_part_lax
    fi

    local debs cnt
    debs=$(ls $build_dir/Deb/*.deb 2>/dev/null)
    cnt=$(echo "$debs" | wc -w)
    if (( cnt > 0 )) \
        && do_part 10 "Install latest antiX debs"; then
        psay $cnt "Install $(pqn %n) .deb package%s"

        for deb in $debs; do
            say "install $(pq "${deb##*/}")"
            apt-get install "$deb"
        done
        end_part_lax
    else
        skip_part 10 "Install latest antiX debs"
    fi

    if gather_any remove \
        && do_part 11 "Remove some packages"; then
        gather_say remove "Remove $(pqn %n) package%s"
        # shellcheck disable=SC2046
        apt-get purge $(gather "remove") $apt_yes --allow-remove-essential
        end_part_strict
    fi

    if gather_any add \
        && do_part 12 "Add some packages"; then
        install_packages add "additional"
        end_part_lax
    fi

    if gather_any reinstall \
        && do_part 13 "Reinstall some packages"; then
        install_packages reinstall Reinstall --reinstall
        end_part_lax

    else
        skip_part 13 "Reinstall some packages"
    fi

    if do_part 14 "!Update/configure X-related programs"; then

        if [[ -n $(which slim) && -e /etc/slim.conf ]]; then
            say "Enable demo as live user in slim.conf"
            sed -i -r '/default_user/ s/^#+//' /etc/slim.conf
        fi

        if [[ -n "$X_TERM_EMULATOR" && -x "$X_TERM_EMULATOR" ]]; then
            say "Set x-terminal-emulator to $(pq "$X_TERM_EMULATOR")"
            update-alternatives --set x-terminal-emulator "$X_TERM_EMULATOR"
        else
            error "Missing or unknown x-term-emulator $(pqw $X_TERM_EMULATOR)"
        fi

    if [[ -e $CURSOR_ICON_THEME ]]; then
        say "Set cursor icon theme to $(pq $CURSOR_ICON_THEME)"
        if is_antiX; then
            local theme dir
            for theme in oxy-white oxy-black Breeze-Snow Breeze-Amber; do
                dir=/usr/share/icons/$theme
                [[ -d "$dir" ]] || continue
                update-alternatives --install /usr/share/icons/default/index.theme x-cursor-theme "$dir"/index.theme 20
            done
        fi
        update-alternatives --set x-cursor-theme $CURSOR_ICON_THEME
    else
        error "Missing or unknown cursor icon theme $(pqw $CURSOR_ICON_THEME)"
    fi

    say "Reconfigure networking sym links"
        update-rc.d networking remove
        update-rc.d networking defaults
        say "Disable bootchart-done"
        update-rc.d "bootchart-done" remove
        end_part_strict
    fi

    local update_flash="update-flashplugin-nonfree"
    if which $update_flash 2>/dev/null && do_part 15 "Get Latest Flash"; then
        $update_flash

        #local flash_selector="flashplayer-selector.sh"
        #if [[ $ARCH = "i386" ]] && which $flash_selector 2>/dev/null; then
        #   say "Set old flash"
        #   $flash_selector
        #fi
        end_part_lax
    fi

    local udev_file="/etc/udev/rules.d/90-fstab-automount"
    if [[ -e $udev_file.live ]]; then
        say "Adding correct suffix to $udev_file.live"
        mv $udev_file.live $udev_file.rules
    fi

    if is_antiX; then
        #update icons cache files
        local update_icons="gtk-update-icon-cache"
        local icon_folder="/usr/share/icons"
        say "Updating icons cache"
        #$update_icons $icon_folder/elementaryXubuntu-dark
        $update_icons $icon_folder/Faenza
        $update_icons $icon_folder/papirus-antix
        #$update_icons $icon_folder/Faenza-Cupertino-mini
    else
        update-icon-caches /usr/share/icons/*
    fi

    if [[ -n $interactive ]] &&  do_part 16 "Manual configuration"; then

        say "Manual configuration"
        local save_cnt
        save_cnt=$(gather_cnt save-selections)
        psay "$save_cnt" "Save selections from $(pqn %n) package%s"
        local package package_re
        for package in $(gather "save-selections"); do
            package_re=${package_re:+$package_re\|}
            package_re=$package_re^$package
        done

        local reconfig_cnt
        reconfig_cnt=$(gather_cnt reconfigure)
        psay "$reconfig_cnt" "Reconfigure $(pqn %n) package%s"

        if (( reconfig_cnt > 0 )) && YES_no "Are you ready"; then

            for package in $(gather "reconfigure"); do
                say "Manual configuration for $(pqn "$package")"
                dpkg-reconfigure -f dialog "$package"
                package_re=${package_re:+$package_re\|}
                package_re=$package_re^$package
            done
        fi

        if (( save_cnt > 0 || reconfig_cnt > 0 )); then
            YES_no "Save these new selections"                     \
                && debconf-get-selections                          \
                | { [[ -n "$package_re" ]] && grep -E "^$package_re" || cat; } | grep -v "[[:space:]]$"  \
                | sort > "$build_dir/$manual_selections"
        fi
        end_part_lax
    else
        skip_part 16 "Manual configuration"
        _say_
        local reconfigure cnt
        reconfigure=$(cut -f1 "$manual_selections_template" | cut -d: -f1 | sort -u)
        cnt=$(echo "$reconfigure" | wc -w)
        psay "$cnt" "Automatic reconfiguration of $(pqn %n) package%s"
        for package in $reconfigure; do
            dpkg-reconfigure -f noninteractive "$package" 2>&1 && echo
        done
        check_errors_lax
    fi

    if do_part 17 "!Update Timezone, hostname, and user accounts"; then
       if [[  -n $TIME_ZONE && -e /usr/share/zoneinfo/$TIME_ZONE ]]; then
            say "Set timezone and localtime to $(pq $TIME_ZONE)"
            echo $TIME_ZONE > /etc/timezone
            DEBIAN_FRONTEND=noninteractive dpkg-reconfigure -f noninteractive tzdata 2>&1 && echo
            end_part_lax
        else
            error "Unknown time zone $(pqw $TIME_ZONE)"
        fi

        : ${NEW_HOSTNAME:=antix1}
        say "Set hostname to $(pq $NEW_HOSTNAME)"
        echo $NEW_HOSTNAME > /etc/hostname

        if [[ -z $NO_SET_HOSTNAME ]]; then
            say "run hostname command"
            hostname -F /etc/hostname
        fi

        local user
        user=${LIVE_USER:-demo}
        if ! grep -q "^$user:" /etc/passwd; then
            say "Set up live user account $(pq $user)"
            grep -q "^$user:" /etc/group || groupadd $user
            local user_pw
            user_pw=$(mkpasswd -m sha-512 $user)
            useradd -s ${ISO_SHELL:="/bin/bash"} -g $user -d /home/$user -p $user_pw $user
        fi

        gather_say user-groups "Add $(pq $user) to $(pqn %n) group%s"

        # add conveinence group vboxsf even if virtualbox guest additions
        # aren not installed
        ! is_antiX && ! grep -q vboxsf /etc/group && groupadd --system vboxsf

        local group
        for group in $(gather user-groups); do
            usermod -a -G $group $user
        done

        say "Set root password"
        local root_pw
        root_pw=$(mkpasswd -m sha-512 root)
        usermod -p $root_pw root

        end_part_strict
    fi

    if do_part 18 "Run second apt-get -f install"; then

        if [[ $DEBIAN_RELEASE != "wheezy" ]] && is_antiX; then
            apt-get $APT_GET_OPTS purge systemd libsystemd0 udev software-properties-common software-properties-gtk
            apt-get $APT_GET_OPTS install --reinstall eudev
            update-rc.d udev defaults
        fi

        apt-get -f $apt_yes install
        # Remove unwanted apps that may have sneaked in.
        say "Run $(pq "apt-get autoremove")"
        apt-get $APT_GET_OPTS autoremove
        end_part_lax
    fi

    local desktop_file default_desktop
    get_template_file default-desktop desktop_file \
        && default_desktop=$(cat "$desktop_file" 2>/dev/null)

    check_errors_strict

    if is_antiX; then
        if [[ -n "$default_desktop" ]] && do_part 19 "!Update SLiM defaults"; then

            if ! [[ -x "$make_xinitrc" ]]; then
                mkdir -p "$(dirname "$make_xinitrc")"    || my_exit
                cp "$tools/make-xinitrc" "$make_xinitrc" || my_exit
            fi

            # shellcheck disable=SC2046
            say "Found desktops $(pq $("$make_xinitrc" --list))"

            say "Create .xinitrc in /etc/skel"
                "$make_xinitrc" "$default_desktop" > /etc/skel/.xinitrc \
                || error "Failed to create/update .xinitrc file"

            if [[ -e /etc/slim.conf ]]; then
                say "Update /etc/slim.conf"
                "$make_xinitrc" --slim || error "Failed to update slim.conf"
            fi

            end_part_strict
        else
            skip_part 19 "Update SLiM defaults"
        fi
    fi

    if is_antiX; then
        say "Customize Mozilla Browser"
        customize_firefox $LOCALE
    else
        ln -fs /usr/share/zoneinfo/America/New_York /etc/localtime
    fi

    _say_
    say "Write version files"
    write_version_files

    if ! is_antiX; then
        mv /etc/antix-version /etc/mx-version
        ln -frs /etc/mx-version /etc/antix-version

        ##mask cgmanager.service - not needed for systemd and masking won't prevent sysVinit from using it.
        systemctl mask cgmanager.service

    fi

    mkdir -p /usr/share/antiX

    dpkg-query -l | sed -n 's/^ii\s\+//p' > $output_dir/package-list.out
    dpkg-query -l | sed -n 's/^ii\s\+//p' > /usr/share/antiX/installed-packages.txt

    # It is easier to do this outside the chroot but by doing it here, the
    # updatedb database will contain the theme files
    if [[ -n $THEME && $THEME != none ]] && do_part 20 "Apply Theme"; then
        apply_theme $THEME
        check_errors_reset
        end_part_strict
    fi
    #-----------------------------------------------------------------
    if ! is_antiX; then
        # fix debian frontend
        say "Configure debconf interface:"
        case $(dpkg-query -f '${db:Status-Abbrev}' -W  debconf-kde-helper 2>/dev/null) in
           i*)
             say "Set debconf frontend: Kde"
             debconf-set-selections < <(printf "debconf\tdebconf/frontend\tselect\tKde\n")
             ;;
           *)
             say "Set debconf frontend: Gnome"
             debconf-set-selections < <(printf "debconf\tdebconf/frontend\tselect\tGnome\n")
             ;;
        esac
    fi
    #-----------------------------------------------------------------

    #run ldconfig incase of any special linking required.
    say "Running ldconfig..."
    ldconfig
    local partial_dir=/var/cache/apt/archives/partial
    say "Fix $(pq $partial_dir) directory"
    mkdir -p $partial_dir
    chown _apt:root -R $partial_dir
    chmod 700 $partial_dir

    if ! is_antiX; then

    say "fix apparmor profile for smbd"
        if [[ -e /etc/apparmor.d/samba/smbd-shares ]]; then
            echo "skip apparmor config"
        else
            [[ -d /etc/apparmor.d/samba ]] || mkdir -p /etc/apparmor.d/samba
            touch /etc/apparmor.d/samba/smbd-shares
        fi
    fi

    local update_cmd=updatedb
    say "Run $update_cmd"
    echo 3 | sudo tee /proc/sys/vm/drop_caches >/dev/null
    sleep 2
    mount -t tmpfs -o size=100k tmpfs /var/cache/apt/archives
    $update_cmd --add-prunepaths /var/cache/apt/archives/ || error "The $(pqw $update_cmd) program failed"
    $update_cmd || error "The $(pqw $update_cmd) program failed"
    umount /var/cache/apt/archives
    sleep 2
    echo 3 | sudo tee /proc/sys/vm/drop_caches >/dev/null
    # We send on the exact kernel name we found
    echo "K_NAME=\"$K_NAME\"" > $output_file

    _say_ "$num_co===============================================================$nc"
    SIGN_OFF="$text_co$ME in chroot done$nc"

    rm -f "$partial_file"
    leave_stage
    my_exit
}

apply_theme() {
    export ISO_ARCH
    local theme=${1:-$THEME}
    [[ $theme = none ]] && return

    local t_dir short_t script
    t_dir=$theme_dir/$THEME
    short_t=$(short_dir $t_dir)
    [[ ! -d $t_dir ]] \
        && error "Theme directory $(pq short_t) does not exist" && return

    local script=$t_dir/theme.sh short_script=$short_t/theme.sh
    [[ ! -e $script ]] && \
        error "Theme script $(pq $short_script) does not exist" && return

    [[ ! -x $script ]] && \
        error "Theme script $(pq $short_script) is not executable" && return

    say "Applying theme $(pq $theme)"
    $script --functions --VERBOSE  && return

    error "There was an error processing the theme script"
}

#------------------------------------------------------------------------------
# Stage 5
#------------------------------------------------------------------------------
do_stage_5() {
	if [[ $stop_5 ]]; then
 		my_exit 0
 	fi

    enter_stage 5 "Finalize and clean the chroot"

    check_sqfs_dir

    sleep 2

    if is_antiX && do_part 21 "!Check kernel's GCC version"; then
        check_kernel_gcc vmlinuz-$K_NAME
        end_part_strict
    fi

    if [[ $FLAV = "base" ]]; then
        say "Change fluxbox and icewm menu-applications files"
        sudo mv -f $sqfs_dir/usr/share/desktop-menu/.fluxbox/menu-applications-fb $sqfs_dir/usr/share/desktop-menu/.fluxbox/menu-applications
        sudo mv -f $sqfs_dir/usr/share/desktop-menu/.icewm/menu-applications-ice $sqfs_dir/usr/share/desktop-menu/.icewm/menu-applications
    fi

    local f wm
    say "Change ownership of 3 menu-applications files"
    for wm in fluxbox icewm jwm; do
        f=$sqfs_dir/usr/share/desktop-menu/.$wm/menu-applications
        [[ -e $f ]] && $SUDO chown 1000:1000 $f
    done

    if is_antiX; then
        say "Change permissions for 2 ppp files"
        $SUDO chmod 666 $sqfs_dir/etc/ppp/chap-secrets
        $SUDO chmod 666 $sqfs_dir/etc/ppp/pap-secrets

         #say "Disable exec for 2 icewm files"
         #$SUDO chmod 644 $sqfs_dir/usr/bin/icewmbg
         #$SUDO chmod 644 $sqfs_dir/usr/bin/icewm-menu-fdo

        if [[ $DEBIAN_RELEASE != "wheezy" && -z "$jbb_mode" ]] && is_antiX; then
            say "Compress /usr/share/doc then delete folder"
            tar -jcvf doc-$full_distro_name.tar.bz2 -C / ${sqfs_dir#/}/usr/share/doc
            sleep 1
            $SUDO find $sqfs_dir/usr/share/doc -type f -name "*.gz" -delete
            $SUDO find $sqfs_dir/usr/lib -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/gdebi/GDebi/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/python3 -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/python3/debpython -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/python3/__pycache__  -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/python3/debpython/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/streamlink/streamlink_cli/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/streamlink/streamlink_cli/utils/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/streamtuner2/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/streamtuner2/bundle/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/streamtuner2/channels/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/system-config-printer/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/system-config-printer/troubleshoot/__pycache__ -type f -name "*.pyc" -delete
            $SUDO find $sqfs_dir/usr/share/system-config-printer/xml/__pycache__ -type f -name "*.pyc" -delete
        fi
    fi

    say "Write initrd_release file"
    write_initrd_release $sqfs_dir $SUDO

    say "Clean out log files and other files"
    for f in $(gather delete-files); do
        eval $SUDO rm -rf $sqfs_dir/$f 2>/dev/null
    done

    (cd $sqfs_dir/var/log && $SUDO touch apt/history.log apt/term.log dpkg.log)

    say "Delete $(pq "/dev/*") in chroot"
    mountpoint -q $sqfs_dir/dev && fatal "$(pqw /dev) is still mounted in squashfs!"
    $SUDO rm -rf $sqfs_dir/dev
    $SUDO mkdir $sqfs_dir/dev

    # Clean up our loose ends (once here instead of after every chroot)
    $SUDO rm -rf $sqfs_dir$build_dir

    # We used LOCAL_MIRROR while building inside the chroot
    set_chroot_mirror $MIRROR "DEFAULT mirror"

    say "Delete $(pq /etc/mtab)"
    $SUDO rm -f $sqfs_dir/etc/mtab

    say "Customize configuration"
    copy_template_dir -o custom-config-files $sqfs_dir

    if is_antiX; then
        say "Add folders for sane"
        $SUDO mkdir $sqfs_dir/usr/lib/sane
        sleep 1
        $SUDO mkdir $sqfs_dir/usr/lib64/sane

        #collect_live_files $live_files_list /usr/share/live-files
        say "Save Live files for snapshot"

        $SUDO rm -rf $sqfs_dir/usr/share/live-files
        $SUDO $tools/installed-to-live populate-live-files $sqfs_dir $sqfs_dir

        if [[ $FLAV = "core" ]] && is_antiX; then
            local if_file=$sqfs_dir/etc/network/interfaces
            if ! grep -q eth0 $if_file; then
                say "Adding eth0 entry to $(pq ${if_file#"$sqfs_dir"})"
                cat << Eth0_entry | $SUDO tee -a $if_file >/dev/null

# The primary network interface
allow-hotplug eth0
iface eth0 inet dhcp
Eth0_entry
            fi
        fi
    fi

    local cached=$sqfs_dir/etc/console-setup/cached_setup_keyboard.sh
    if [[ -e $cached ]]; then
        say "Removing console-setup cached files"
        $SUDO rm $cached*
    fi

    #local exclude_files="$sqfs_dir/usr/share/excludes/*.list"
    #local efile ofile
   # for efile in $exclude_files; do
   #     ofile=${efile%.list}.orig
   #     $SUDO cp $efile $ofile
   #     $SUDO chmod a-wx $ofile
   # done

    local bc_fw_bin=$sqfs_dir/lib/firmware/brcm/brcmfmac4350-pcie.bin
    local bc_fw_txt=${bc_fw_bin%.bin}.txt
    local bc_fw_name
    bc_fw_name=$(basename $bc_fw_bin)

    if [[ -e $bc_fw_bin && ! -e $bc_fw_txt ]]; then
        say "Linking to $(pq $bc_fw_name)"
        $SUDO ln -s $bc_fw_name $bc_fw_txt
    fi

    local vim_bin=$sqfs_dir/usr/bin/vim
    if [[ -x $vim_bin.tiny && ! -e $vim_bin ]]; then
        say "Making /usr/bin/vim symlink to vim.tiny"
        $SUDO ln -s vim.tiny $vim_bin
    fi

    local cdrecord_bin=$sqfs_dir/usr/bin/cdrecord
    local wodim_bin=$sqfs_dir/usr/bin/wodim
    if is_antiX && [[ -x $wodim_bin && ! -e $cdrecord_bin ]]; then
        say "Making /usr/bin/cdrecord symlink to wodim"
        $SUDO ln -s wodim $cdrecord_bin
    fi

    local cli_cc_prog=antiX-cli-cc
    if [[ -x $sqfs_dir/usr/local/bin/$cli_cc_prog ]]; then
        local dir file
        for dir in /root /etc/skel; do
            file=$sqfs_dir$dir/.bash_history
            #[[ -e $file ]] && continue

            say "Putting command line control centre into Bash history in $(pq $dir)"
            echo $cli_cc_prog | $SUDO tee $file >/dev/null
        done

    # Make sure root's history is either clobbered (above) or erased
    elif [[ -e $sqfs_dir/root/.bash_history ]]; then
        say "Deleting root's history"
        $SUDO rm -f $sqfs_dir/root/.bash_history
    fi

    if ! is_antiX; then
        #remove symlink for /etc/resolv.conf
        say "Removing symlink for /etc/resolv.conf"
        $SUDO rm -f $sqfs_dir/etc/resolv.conf

        #remove old linux image files
        say "Removing *.old files from / "
        $SUDO rm -f $sqfs_dir/*.old
    fi

#rename diverted files under /var/lib/dpkg-diverts-mx/ to drop .dpkg-dist extension
	find $sqfs_dir/var/lib/dpkg-diverts-mx/ -type f -name '*.dpkg-dist' -print0 |	while IFS= read -r -d '' file; do
    	$SUDO mv "$file" "${file%.dpkg-dist}"
	done

    leave_stage
}

#------------------------------------------------------------------------------
# Stage 6
#------------------------------------------------------------------------------
do_stage_6() {
    enter_stage 6 "Prepare iso directory"
    # (0) Populate iso dir with boilerplate files
    # (1) Copy flavour-dependent bootloader.cfg files via inheritance
    copy_template_dir -u iso $iso_dir

    say "Make/customize bootloader configuration"

    # Directories under iso/
    local isolinux_dir=$iso_dir/boot/isolinux
    local syslinux_dir=$iso_dir/boot/syslinux

    # Directories with unpacked cpio archives
    local isolinux_cpio=$work_dir/isolinux-cpio
    local syslinux_cpio=$work_dir/syslinux-cpio

    unpack_gfx_cpio isolinux $isolinux_cpio
    unpack_gfx_cpio syslinux $syslinux_cpio

    # (2) Let bootloader know if we use a 64-bit kernel
    [[ $ARCH = amd64 ]] && echo 1 > $isolinux_cpio/64bit
    [[ $ARCH = amd64 ]] && echo 1 > $syslinux_cpio/64bit

    # (3) Update Fn menu in bootloader
    local boot_menu
    get_template_file gfxboot.menu boot_menu
    if [[ -n $boot_menu ]]; then
        update_gfxboot_menu $boot_menu $isolinux_cpio/gfxboot.cfg
        update_gfxboot_menu $boot_menu $syslinux_cpio/gfxboot.cfg "key.F8=save"
    fi

    # (4) Mostly for flavour dependent desktop.men file
    #     could also be used to over-write add other files in the gfx-cpio
    copy_template_dir -u gfx-cpio $isolinux_cpio
    copy_template_dir -u gfx-cpio $syslinux_cpio

    # (5)
    say "Fill in bootloader template files"
    local bootloader_data=$output_dir/bootloader-data
    # shellcheck disable=SC2154
    eval local boot_options=\$${DISTRO_NAME}_LIVE_BOOT_OPTIONS
    # shellcheck disable=SC2154
    cat << Bootloader_Data > $bootloader_data
      DISTRO_NAME="$DISTRO_NAME"
   DISTRO_VERSION="$DISTRO_VERSION"
 FULL_DISTRO_NAME="$full_distro_name"
         ISO_ARCH="$ISO_ARCH"
        CODE_NAME="$CODE_NAME"
             FLAV="$FLAV"
          OPTIONS="$boot_options"
     CORE_OPTIONS="$CORE_LIVE_BOOT_OPTIONS"
     RELEASE_DATE="$RELEASE_DATE"
Bootloader_Data

    $SUDO mkdir -p $sqfs_dir/usr/share/antiX/
    $SUDO cp $bootloader_data $sqfs_dir/usr/share/antiX/

    $tools/bootloader-template -i --data=$bootloader_data $iso_dir
    $tools/bootloader-template -i --data=$bootloader_data $isolinux_cpio/en.hlp
    $tools/bootloader-template -i --data=$bootloader_data $syslinux_cpio/en.hlp

    # (6) Create/append-to text-only bootloader menu (.msg file)
    local isolinux_cfg=$isolinux_dir/isolinux.cfg
    local syslinux_cfg=$syslinux_dir/syslinux.cfg

    if [[ -n $MEM_TEST_BUG ]]; then
        say "Comment out memtest in $(basename $syslinux_cfg)"
        sed -i "/memtest/,$ s/^/#--memtest /" $syslinux_cfg
    fi

    $tools/make-isolinux-menu $isolinux_cfg >> $isolinux_dir/readme.msg
    $tools/make-isolinux-menu $syslinux_cfg >> $syslinux_dir/readme.msg

    # (7) Enabled "Save" menu on syslinux side only
    sed -r -i "/key\.F.=save/ s/^\s*;+\s*//" $syslinux_cpio/gfxboot.cfg

    # (7.1) add ask+save entry to syslinux console menu
    local con_menu=$syslinux_cpio/console.men
    grep -q "ask+save" $con_menu || echo "ask+save \`vga=ask gfxsave" >> $con_menu

    # (8) Create/update text (UEFI) desktop menu based on menu in isolinux cpio archive
    local desktop_men=$isolinux_cpio/desktop.men
    if [[ -e $desktop_men ]]; then
        say "Create desktop text boot-menu"
        $SUDO $tools/make-text-menu desktop $boot_menu_dir $desktop_men
        local append_menu dir targ
        get_template_file append-to-desktop.men append_menu
        for dir in $isolinux_cpio $syslinux_cpio; do
            targ=$dir/desktop.men
            [[ -e $targ ]] || continue
            say "Append to $(basename $dir)/$(basename $targ)"
            cat $append_menu >> $targ
        done
    fi

    # (9)
    sed -i 's/APPEND hd0/APPEND hd1/' $syslinux_dir/syslinux.cfg

    # (10)
    if [[ $FLAV = "core" ]]; then
        say "Use large font in bootloader for $(pq $FLAV) system"
        sed -i "s/16x16.fnt/16x16aa.fnt/"  $isolinux_cpio/gfxboot.cfg $syslinux_cpio/gfxboot.cfg
    fi

    # say "Make efi.img"
    # $SUDO $tools/make-efi-img $iso_dir "$DISTRO_NAME-uefi"

    repack_gfx_cpio isolinux $isolinux_cpio
    repack_gfx_cpio syslinux $syslinux_cpio

    echo "$fancy_name" > $iso_dir/version

    local sneaky=".disk"
    say "Add sneaky $sneaky/ directory"
    mkdir -p $iso_dir/$sneaky
    cp $iso_dir/version $iso_dir/$sneaky/info


    if [[ -z $iso_only ]]; then
        # Copy the kernel from the squashfs
        say "Copy kernel $(pq $K_NAME) to $(pq vmlinuz) in iso directory"
        local kernel_file=$sqfs_dir/boot/vmlinuz-$K_NAME
        [[ -r $kernel_file ]] || error "Could not find kernel ${kernel_file##*squashfs} in squashfs dir"

        local vmlinuz=$iso_dir/antiX/vmlinuz
        mkdir -p $iso_dir/antiX
        cp $kernel_file $vmlinuz || my_exit
        md5sum_file $vmlinuz
    fi

    # Create custom initrd.gz including modules from the squashfs kernel
    if [[ -e $initrd_dir ]]; then
        say "Clear out initrd directory"
        rm -rf $initrd_dir
    fi

    mkdir -p $initrd_dir

    local initrd_src=$template/COMMON/initrd

    if [[ -d $initrd_src ]]; then
        copy_template_dir -u initrd $initrd_dir
    else
        error "No $initrd_src/ or $initrd_src.gz found"
    fi

    say "Write initrd_release file"
    write_initrd_release $initrd_dir

    if [[ -z $iso_only ]]; then
        say "Copy $(pq $K_NAME) modules into initrd"

        rm -rf $initrd_dir/lib/modules/

        # Note: please use built-in list so we are all in sync. Thanks!     #anticap
        $tools/copy-initrd-modules --encrypt --very-quiet --kernel $K_NAME --from $sqfs_dir --to $initrd_dir --count

        #anticap#$tools/copy-initrd-programs --to $initrd_dir --clean
        $tools/copy-initrd-programs --encrypt --quiet --to $initrd_dir --from $sqfs_dir
    fi

    local initrd_gz=$iso_dir/antiX/initrd.gz
    say "Create initrd.gz"
    (cd $initrd_dir && find . | cpio -o -H newc --owner root:root --quiet) \
        | $GZIP -9 > $initrd_gz

    md5sum_file $initrd_gz

    [[ -z "$iso_only" ]] && copy_second_kernel $sqfs_dir/boot $iso_dir/antiX

    say "Write auxiliary information"

    [[ $iso_only ]] && touch $work_dir/package-list.out

    local misc_dir=$iso_file_dir/misc/$full_distro_name
    mkdir -p $misc_dir
    gather package                               > $misc_dir/package-list.antiX
    gather exclude-bootstrap                     > $misc_dir/exclude-list
    pretty_output | strip_color                  > $misc_dir/info
    awk '{ print $1}' $work_dir/package-list.out > $misc_dir/package-list.all
    write_version_info                           > $misc_dir/version-info

    cp $work_dir/package-list.out                  $misc_dir/package-list.full

    say "Initializing random number generator"
    local seed_file=$iso_dir/antiX/$seed_fname
    dd status=none if=/dev/urandom of=$seed_file bs=1 count=512

    leave_stage
}

#------------------------------------------------------------------------------
# Stage 7 creates the squashfs file
#------------------------------------------------------------------------------
do_stage_7() {
    enter_stage 7 "Create squashfs file"
    umount_chroot

    say "Run depmod one last time"
    $SUDO depmod --basedir $sqfs_dir $K_NAME

    say "Clear /run directory"
    $SUDO rm -rf $sqfs_dir/run
    $SUDO mkdir -p $sqfs_dir/run

    if [[ -x $sqfs_dir/usr/bin/updatedb ]]; then
        say "Run updatedb one last time"
        $SUDO chroot $sqfs_dir /usr/bin/updatedb 2>/dev/null || true
    fi

    say "Update font cache"
    [[ -x $sqfs_dir/usr/bin/fc-cache ]] && $SUDO chroot $sqfs_dir fc-cache -r -s -v

    if ! is_antiX; then
        [[ -x $sqfs_dir/usr/bin/fc-cache ]] && $SUDO chroot $sqfs_dir fc-cache -r -v /usr/share/fonts/extra
        [[ -d $sqfs_dir/etc/skel/.cache/fontconfig ]] || $SUDO mkdir -p $sqfs_dir/etc/skel/.cache/fontconfig

        $SUDO rm -f $sqfs_dir/etc/skel/.cache/fontconfig/*
        $SUDO cp $sqfs_dir/var/cache/fontconfig/* $sqfs_dir/etc/skel/.cache/fontconfig/
    fi

    if  [[ -n $zstd_override ]]; then
        COMPRESSION_TYPE="zstd"
        COMPRESSION_TYPE_CODE="-comp zstd -Xcompression-level 15 -b 262144"

    elif [[ -n $lz4_override ]]; then
        COMPRESSION_TYPE="lz4"
        COMPRESSION_TYPE_CODE="-comp lz4 -Xhc"
    fi

    say "Build the $COMPRESSION_TYPE compressed linuxfs file. This takes time and uses a lot of CPU power."

    local linuxfs_file=$iso_dir/antiX/linuxfs
    rm -f $linuxfs_file

    start_timer
    #                                                    262144 = 0x40000
    #$SUDO mksquashfs $sqfs_dir $linuxfs_file -comp xz -b 262144

#also capture uncompressed filesystem output into a variable and place that in a file in the SQFILE_DIR location

    local output="/tmp/mksquash_output"
    local UNCOMPRESSEDSIZE_FILE UNCOMPRESSEDSIZE
    UNCOMPRESSEDSIZE_FILE="$iso_dir/antiX/linuxfs.info"
    $SUDO unbuffer -p mksquashfs $sqfs_dir $linuxfs_file $COMPRESSION_TYPE_CODE | tee $output
    UNCOMPRESSEDSIZE=$(grep "uncompressed filesystem" "$output" | cut -d"(" -f2 | cut -d" " -f1)
    echo "UncompressedSizeKB=$UNCOMPRESSEDSIZE">"$UNCOMPRESSEDSIZE_FILE"
    rm "$output"
    local size
    size=$(du_size $linuxfs_file)
    end_timer "create $(pqn $size) squashfs file"
    md5sum_file $linuxfs_file

    leave_stage
}

#------------------------------------------------------------------------------
# Stage 8 creates the iso file.
#------------------------------------------------------------------------------
do_stage_8() {

	if [[ $stop_8 ]]; then
 		my_exit 0
 	fi

    enter_stage 8 "Create iso file"

    report_size $iso_dir

    local iso_file=$full_distro_name.iso
    mkdir -p $iso_file_dir
    local full_iso_file=$iso_file_dir/$iso_file
    say "Build the live $(pq $iso_file) file"

    local file full
    for file in vmlinuz linuxfs initrd.gz; do
        full=$iso_dir/antiX/$file
        [[ -e $full ]] && md5sum_file $full
    done

    start_timer

    local file_dir chown_opts
    file_dir="$full_iso_file $iso_dir"
    chown_opts="-uid 0 -gid 0"
    say "Using $(pq "$(basename $MAKE_ISO)") to make iso file"
    if [[ -z ${MAKE_ISO%%*xorriso} ]]; then
        $SUDO chown -R root:root $iso_dir
        make_xorriso_iso $MAKE_ISO $file_dir
        $SUDO chown -R $UID $iso_dir

    elif has_option $MAKE_ISO -e; then
        make_uefi_iso "$MAKE_ISO" "$chown_opts -e" $file_dir

    elif has_option $MAKE_ISO -eltorito-platform; then
        make_uefi_iso "$MAKE_ISO" "$chown_opts -eltorito-platform 0xEF -eltorito-boot" $file_dir

    else
        warn "Disabling 'dd' live-usb UEFI booting"
        $MAKE_ISO -l -V antiXlive -R -J -pad -no-emul-boot -boot-load-size 4  \
            -boot-info-table -gid 0 -uid 0 -b boot/isolinux/isolinux.bin      \
            -c boot/isolinux/isolinux.cat -o $full_iso_file $iso_dir 2>&1 \
            || error "iso file creation failed"

            isohybrid $full_iso_file
    fi

    size=$(du_size $full_iso_file)
    end_timer "create $(pqn $size) iso file"

    if [[ $SIGN_FILES == true ]]; then
        say "Sign $(basename $full_iso_file)"
        rm -f $full_iso_file.sig 2>/dev/null
        local gpg_sudo
        is_antiX && gpg_sudo=$SUDO
        $gpg_sudo gpg --output $full_iso_file.sig --detach-sign $full_iso_file
    fi

    #md5sum_file $full_iso_file
    sha256sum_file $full_iso_file
    zsyncmake_file $full_iso_file


    if is_antiX && [[ -L "$ISO_SYMLINK" ]];then
        say
        say "Create symlink $(pq $ISO_SYMLINK) to iso file"
        ln -sf $full_iso_file $ISO_SYMLINK
    fi

    say2 "Your live $(pq $iso_file) is in $(pq Remaster/iso-files) ready to be tested"

    if [[ -z $full_auto ]] && mountpoint -q $sqfs_dir; then
        echo
        yell "Run $(pqw $ME) again or run $(pqw $ME -F) to cache and umount the tmpfs"
        yell "Or use the $(pqw "-A (--AUTO)") flag next time to do this automatically"
       echo
   fi

    leave_stage

    echo "$text_co$ME$bold_co done$nc" > $sign_off_file
    # Go on to final stage when in auto-mode
    [[ -n $full_auto ]]  || my_exit
}

#------------------------------------------------------------------------------
# State 9 cleans things up and clears the stage for staring over.
#------------------------------------------------------------------------------
do_stage_9() {

    enter_stage 9 "Clean up and prepare to start over"

    local s links
    for s in initrd iso sqfs work; do
        [[ -L $script_dir/$s ]] && links="$links $script_dir/$s"
    done

    umount_tmpfs
    clear_outputs

    local rel_work_dir
    rel_work_dir=Remaster/work/$(basename $work_dir)
    if [[ -n $delete_all ]]; then
        say "Delete entire work directory $(pq $rel_work_dir)"
        $SUDO rm -rf $work_dir
        [[ -n $links ]] && rm $links

    elif [[ -n $delete_mode ]]; then
        say "Delete squashfs directory $(pq $rel_work_dir/squashfs)"
        $SUDO rm -rf $sqfs_dir
        rm -f $script_dir/squashfs

        if yes_NO "Delete everything else in $(pq $rel_work_dir)"; then
            $SUDO rm -rf $work_dir
            [[ -n $links ]] && rm $links
        fi

    elif yes_NO "Delete entire work directory $(pq $rel_work_dir)"; then
        $SUDO rm -rf $work_dir
        [[ -n $links ]] && rm $links

    elif yes_NO "Delete squashfs directory $(pq $rel_work_dir/squashfs)"; then
        $SUDO rm -rf $sqfs_dir
        rm -f $script_dir/sqfs
    fi

    my_exit
}

do_save() {
    (( stage > 0 )) || return 1
    force_cache $chroot_cache_opts
    return 0
}

#------------------------------------------------------------------------------
# enter_stage stage title
# $1 is used when we grep and sed ourselves to find out info about the various
# stages. See do_pretend() and --show-stages.
#
# titles starting with "!" skip the continue question. Make sure we don't get
# caught in an endless loop. Usually only needed during development.
#------------------------------------------------------------------------------
enter_stage() {
    title=${2#!}

    has_word EXIT_STAGE $stage && vexit "via EXIT_STAGE=$EXIT_STAGE ${text_co}at stage $(pqn $stage)$nc"
    [[ -n $stage ]] && grep "^$stage$" $did_stage_file 2>/dev/null && fatal "Re-entering stage $stage"

    _say_ "\n${bold_co}Stage $num_co$stage$text_co: $title$nc @ $(printf '%(%F %T %Z)T' -1)"
    [[ -z $quiet_mode ]] && (( stage > 0 )) \
        && say "Making: $(pq $full_distro_name) with kernel $(pq $K_NAME)"

    has_word  ASK_STAGE $stage \
        && YES_no "ASK_STAGE: Exit" && vexit "${text_co}at stage $(pqn $stage)$nc"

    echo $stage >> $did_stage_file

    [[ -z $auto_mode && ! $2 =~ ^! ]] \
        && ! YES_no_loud "\nDo you want to continue" && my_exit

    touch $err_file
    check_errors_reset

    start_timer STAGE_TIME
    return 0
}

leave_stage() {
    touch $output_file
    (( $# > 0 )) && return
    _end_timer_ STAGE_TIME "Stage $stage"
    check_errors_strict
    return 0
}
#==============================================================================
# Routines for tmpfs mounts
#==============================================================================

# shellcheck disable=SC2120
mount_tmpfs() {
    local dir needed name
    dir=${1:-$sqfs_dir}
    needed=$(((2500 + 70 * $(gather_cnt package)) / 10))
    name=$(basename $dir)

    [[ -n $dir ]] || fatal "Can't mount_tmpfs() without a directory specified"

    if mountpoint -q $dir; then
        say "tmpfs is already in use"
        return
    fi
    local cache free swap
    # shellcheck disable=SC2046
    eval $(get_cache_free_swap)
    say "The tmpfs will require $(pqn ${needed}) meg of RAM"
    display_cache_free_swap $cache $free $swap

    local balance
    balance=$((free + swap - needed))
    (( balance < 0   )) && fatal "Need more memory than is available in RAM and swap"
    (( balance < 200 )) && error "Less than 200 Meg memory margin (free RAM + swap - needed)"

    YES_no "Mount as tmpfs" || return

    # Try to make a backup if directory exists and is not empty
    if [[ -d $dir ]] && [[ -n $(ls $dir) ]]; then
        if [[ ! -d $dir.bak ]]; then
            say "Save $name dir at $name.bak"
            mv $dir $dir.bak
        else
            say "Not saving $name/ because $name.bak already exists"
        fi
    fi

    say "mount $(pq $name/) as tmpfs size: $(pqn ${needed})m"

    mkdir -p $dir
    if ! $SUDO mount -t tmpfs -o noatime,size=${needed}m tmpfs $dir; then
        check_errors_reset
        error "Failed to mount $name/ as tmpfs"
    fi
}

# shellcheck disable=SC2120
umount_tmpfs() {
    local dir name
    dir=${1:-$sqfs_dir}
    name=$(basename $dir)

    [[ -n $dir ]] || fatal "Can't umount_tmpfs() without a directory specified"

    mountpoint -q $dir || return

    say "About to umount $(pq $name)"
    report_size $dir
    # shellcheck disable=SC2046
    YES_no_loud "Cache chroot directory before umount" && force_cache $chroot_cache_opts

    YES_no_loud "Clear out $name/ and umount it" || return 1

    check_sqfs_dir $dir
    $SUDO rm -rf "$(dirname $dir)"/squashfs/*
    $SUDO umount $dir
    mountpoint -q $dir || return
    warn "name did not simply umount. Trying -l (lazy option)"
    $SUDO umount -l $dir
    mountpoint -q $dir || error "Could not umount $name"

}

find_all_tmpfs() {
    local dir type name
    for dir in "$remaster_dir"/work/*/squashfs; do
        [[ -d $dir ]]          || continue
        mountpoint -q $dir   || continue
        type=$(df -Tm $dir | awk '{type=$2} END {print type}')
        [[ $type = tmpfs ]]  || continue
        name=${dir#"$remaster_dir"/work/}
        echo ${name%/squashfs}
    done
}

check_all_tmpfs() {
    local name dir used size all_tmpfs cnt
    all_tmpfs=$(find_all_tmpfs)
    [[ -n $all_tmpfs ]] || return 1
    cnt=$(echo "$all_tmpfs" | wc -w)
    psay $cnt "Found $(pqn %n) tmpfs mount point%s"

    for name in $all_tmpfs; do
        display_tmpfs $name
    done

    YES_no "Cache or umount any of these" || return 0

    for name in $all_tmpfs; do
        echo
        local dir=$remaster_dir/work/$name/squashfs
        display_tmpfs $name
        YES_no_loud "Cache chroot directory before umount" && force_cache chroot "$name" "$dir"
        YES_no "Clear and umount this directory" || continue

        $SUDO rm -rf "$(dirname $dir)"/squashfs/*
        $SUDO umount -l $dir
    done

    return 0
}

display_tmpfs() {
    local name=$1
    local fmt dir sizes
    fmt="    $high_co%-35s $(pqn %6s)/$(pqn %s) meg$nc\n"
    dir=$remaster_dir/work/$name/squashfs
    sizes=$(df -m $dir | awk '{size=$2; used=$3} END {print used " " size}')
    # shellcheck disable=SC2059
    printf "$fmt" "$name" $sizes
}

kill_chroot_procs() {
    local pids
    pids=$($SUDO lsof 2>/dev/null | grep $sqfs_dir | tail -n +2 | awk '{print $2}' | sort -u)
    if [[ -z $pids ]]; then
        say "No remaining chroot processes found"
        return
    fi
    local cnt
    cnt=$(echo "$pids" | wc -l)
    psay $cnt "Found $(pqn %n) chroot process%es still running"
    _say_ "$(my_ps "$pids")"

    YES_no "Kill these processes" || return
    $SUDO kill $pids
    #FIXME check for survivors
}
#==============================================================================
# Error detection on STDERR output
#
# All the stderr output ends up in $err_file. We periodically check this file
# for new errors.
#
# check_errors_reset()
#   Ignore all previous errors
#
# check_errors_strict()
#    assume previous error messages are fatal except those matching regexes.
#
# check_errors_lax()
#    assume all errors are non-fatal except those matching a list of regexes.
#
# If $ask_errors is true then the user is given a chance to modify the list of
# strict exceptions and try again before we error out.
#==============================================================================

check_errors_reset() {
    [[ -e $err_file ]] || touch $err_file
    local offset
    offset=$(cat $err_file 2>/dev/null | wc -l)
    : ${offset:=0}
    ERROR_OFFSET=$((offset + 1))
    #_say_ "check_errors_reset"
    return 0
}

check_errors_strict() { _check_errors_ STRICT "$STRICT_EXCEPTIONS"  -v ;}
check_errors_lax()    { _check_errors_ LAX    "$LAX_ERRORS"            ;}

_check_errors_() {
    local type=$1 regex=$2 flag=$3

    [[ -n $disable_errors ]] && return
    : ${ERROR_OFFSET:=1}
    #say "Checking for $(pq $type) errors @offset $ERROR_OFFSET"
    local errors cnt
    while true; do

        if [[ -n $regex ]]; then
            errors=$(tail -n +$ERROR_OFFSET $err_file | grep -E ${flag:+"$flag"} "($regex)" | grep -Ev "^\s*$")

        elif [[ $type = STRICT ]]; then
            errors=$(tail -n +$ERROR_OFFSET $err_file | grep -Ev ${flag:+"$flag"} "^\s*$")
        fi

        [[ -z $errors ]] && check_errors_reset && return

        local cnt
        cnt=$(echo "$errors" | wc -l)
        if [[ -n $no_check_errors ]]; then
            say "$(plural $cnt "Skipping $(pqn %n) $type error%s")"
            return
        fi

        yell "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
        say_in $err_co "$errors"
        #_say_ "$(echo "$errors" | sed -e "s/^/$err_co/" -e "s/$/$nc/")"
        yell "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
        yell "$(plural $cnt "Found $(pqw %n) $type error%s")"
        [[ -n $ask_errors ]] || break
        YES_no "Retry"    || break
        read_error_regexes
    done

    check_errors_reset
    if YES_no "Ignore this error"; then
        say "Error ignored"
        return
    fi

    yell "Exiting"

    # Almost never needed except in middle of prep chroot stage
    clear_pids
    umount_chroot

    my_exit 1
}

read_error_regexes() {

    [[ -r $lax_regex_file ]] || error "Could not find/read lax-error file $file"
    LAX_ERRORS=$(join_lines $lax_regex_file "|")

    [[ -r $strict_regex_file ]] || error "Could not find/read strict-exception file $file"
    STRICT_EXCEPTIONS=$(join_lines $strict_regex_file "|")
}

join_lines() {
    local sep file=$1
    while read -r line; do
        echo -n "$sep$line"
        sep=${2:-,}
    done << Join_Lines
$(grep "[^\s]" $file)
Join_Lines

}

#==============================================================================
# Routines used inside of $chroot_stage
#==============================================================================

#------------------------------------------------------------------------------
# do_part part-num title
#
# Give user control over which parts inside of stage-3 get run.
# Time this parts and report how long each one took.
#
# Each *_PART variable can contain a comma separated list of part numbers.
# Return true if this part is supposed to run. Returns false otherwise.
# This is totally controled by the *_PART variables.
#
# For example, to only run part 4, set RUN_PART=4 SKIP_PART=a then part 4
# will run all all other parts will be skipped.
#
# Note that DID_PART is not yet implemented elsewhere. It could be used to
# make sure each part only runs once.
#------------------------------------------------------------------------------
do_part() {
    _end_part_
    local part=$1 title=${2#!}
    local pnum="$text_co$part$nc" ptitle="${title2:-$title}"
    LAST_PART=$part
    _do_part_ || return 1

    local pnum
    pnum="$(printf "%2d" $part)"

    _say_
    _say_ "${bold_co}Part $num_co$pnum$text_co: $ptitle$nc @ $(printf '%(%F %T %Z)T' -1)"
    [[ -n $quiet_mode ]] || _say_ "Making: $full_distro_name"

    # Update window title
    echo -ne "\e]0;$ME stage:$stage part:$part $full_distro_name\a"

    LAST_TITLE=$2
    start_timer PART_TIME

    return 0
}

_do_part_() {

    if has_word SHELL_PART $part; then
        _say_ "Breakpoint at $pnum: $ptitle"
        bash --rcfile /Build/bashrc2
    fi

    # If TEST_PART is non-empty and contains at least one digit
    if [[ $TEST_PART =~ ^[0-9] ]]; then
        if ! has_word TEST_PART $part; then
            _say_ "${bold_co}Test mode:$nc Skip part ($pnum) $title"
            return 1
        fi

    elif has_word ASK_PART $part; then
        YES_no_loud "Run $nc($pnum) $ptitle" || return 1

    elif has_word RUN_PART $part; then
        return 0

    elif has_word SKIP_PART $part; then
        _say_ "Skip part ($pnum) $title"
        return 1

    fi

    return 0
}

skip_part() {
    local part=$1 pnum
    pnum="$(printf "%2d" $part)"
    _say_
    _say_ "Part $pnum: $2 -- skipped --"
}

#------------------------------------------------------------------------------
# end_part
# Report timing information about the last part that was run. Only acts the
# first time it is called after a do_part() call returns true. Is disabled if
# the previous part title begins with "!" so we don't have to time everything
# that is controlled by do_part().
#------------------------------------------------------------------------------
end_part_lax() {
    check_errors_lax
    _end_part_
}

end_part_strict() {
    check_errors_strict
    _end_part_
}

show_tmpfs_and_mem() {
    [[ -n $do_fast && "$stage" == "$chroot_stage" ]] || return
    local used total
    used=$(df -m / 2>/dev/null | awk '{used=$3}  END {print used}')
    total=$(df -m / 2>/dev/null | awk '{total=$2} END {print total}')
    say_fmt "tmpfs used"   $used
    say_fmt "tmpfs total"  $total
    display_cache_free_swap
}

_end_part_() {
    local title
    title="$(echo "$LAST_TITLE" | strip_color)"

    LAST_TITLE=
    if [[ ! $title =~ ^! ]]; then
        _end_timer_ PART_TIME "$title"
    fi

    [[ -n $LAST_PART && -w $partial_file ]] && ! grep "^$LAST_PART" $partial_file \
        && echo $LAST_PART >> $partial_file

    if  [[ -n $LAST_PART ]] && has_word EXIT_PART $LAST_PART; then
        _say_ "Exit after part ($text_co$LAST_PART$nc) $title"
        my_exit
    fi
    LAST_PART=
}

list_newer_procs() {
    local newer pid ref=${1:-$$}

    for pid in $(pgrep .); do
        (( pid > ref ))         || continue
        is_zombie_or_kthread $pid && continue
        newer=$newer,$pid
    done
    if [[ -n $newer ]]; then
        Say "Processes started after the chroot:"
        my_ps "$newer"
    else
        say "No newer processes found"
    fi
}

my_ps() {
    local pids=${1//[[:space:]]/,}
    [[ -n $pids ]] || return
    ps -o "$PS_FORMAT" -p ${pids#,} | sed -e "1 s/^/$text_co/" -e "1 s/$/$nc/"
}

get_cache_free_swap() {
    local lab free cache swap
    while read -r lab total used free cache; do
        case $lab in
            Mem:) echo free=$free
                  echo cache=$cache ;;
           Swap:) echo swap=$free   ;;
        esac
    done << Get_Free
$(free -m)
Get_Free
}

display_cache_free_swap() {
    local cache=$1 free=$2 swap=$3
    # shellcheck disable=SC2046
    (( $# == 3 )) || eval $(get_cache_free_swap)
    say_fmt "Free Mem"  $free
    say_fmt "Free Swap" $swap
    say_fmt "Cached"    $cache
}

is_zombie_or_kthread() {
    local len
    len=$(wc -c /proc/$pid/cmdline 2>/dev/null) || return 0
    [[ -z $len ]]                                     && return 0
    [[ "${len%% *}" = 0 ]]
}

#------------------------------------------------------------------------------
# search_for_k_name
# Assume K_NAME contains the name of a kernel image with "*" as a wildcard.
# Use "apt-cache search" to find all kernel images that match the pattern and
# choose the last one (which should be the highest version). Set K_NAME to
# the specfic kernel we found.
#------------------------------------------------------------------------------
search_for_k_name() {
    local search_name
    search_name=$(echo "$K_NAME" | sed -e "s/\./\\./g" -e "s/\*/[0-9]+.*/g" -e "s/\+/\\+/g")
    say "Search for kernel matching regex $(pq "$K_NAME")"
    local name

    # Check if we're running inside chroot (Stage 4)
    if [[ "$script_dir" == "$build_dir" ]]; then
        # We're inside chroot - use apt-cache directly
        say "Running inside chroot environment, updating package cache"
        apt-get update -qq

        # Search for kernel packages - try broader search patterns
        say "Searching for available kernel packages..."
        local all_kernels
        all_kernels=$(apt-cache search "^linux-image-" | cut -d" " -f1)
        say "Available kernels in repository:"
        echo "$all_kernels" | head -10

        # Try the specific search with version sorting to get the highest version
        name=$(apt-cache search "^linux-image-$search_name" | cut -d" " -f1 | grep -vE "\-(dbg|unsigned|signed-template|cloud|rt)" | sort -V | tail -1)

        # Backup: if no specific kernel found, try broader search
        if [[ -z $name ]]; then
            say "No specific kernel found, trying broader search..."
            name=$(apt-cache search "^linux-image-" | cut -d" " -f1 | grep -vE "\-(dbg|unsigned|signed-template|cloud|rt)" | sort -V | tail -1)
        fi

        if [[ -z $name ]]; then
            warn "No kernel matching $(pqw "$K_NAME") found in target repository. Available kernels:"
            apt-cache search "^linux-image-" | cut -d" " -f1 | head -20
            my_exit
        fi
    else
        # We're outside chroot - fallback to host system
        say "Running on host system, using host package cache"
        name=$(apt-cache search "^linux-image-$search_name$" | cut -d" " -f1 | grep -vE "\-(dbg|unsigned|signed-template|cloud|rt)" | sort -V | tail -1)
        if [[ -z $name ]]; then
            warn "No kernel matching $(pqw "$K_NAME") found. Possible kernels:"
            apt-cache search linux-image-.\*-antix | cut -d" " -f1
            my_exit
        fi
    fi

    K_NAME=${name#linux-image-}
    say "Found kernel $(pq $K_NAME)"
}

vmlinuz_gcc_version() {
    local vmlinuz=$1
    $tools/extract-vmlinux $vmlinuz  2>/dev/null | strings \
        | sed -n -r '/gcc version/ s/.*gcc version ([0-9.]+).*/\1/p' | head -1
}

check_kernel_gcc() {
    local kernel=vmlinuz-$K_NAME
    local vmlinuz=$sqfs_dir/boot/$kernel
    [[ ! -r $vmlinuz ]] \
        && error "Could not find kernel file: $(pqw $kernel)" && return

    local kgcc
    kgcc=gcc-$(vmlinuz_gcc_version $vmlinuz)

    [[ $kgcc = gcc- ]] \
        && error "Could not find gcc version for $(pqw $kernel)" && return

    say "Kernel $(pq $K_NAME) was compiled with $(pq $kgcc)"

    local kalt gcc
    kalt=$(echo $kgcc | sed -n -r 's/([0-9]+\.[0-9]+)\.[0-9]+$/\1/p')

    for gcc in $kgcc $kalt; do
        [[  -e $sqfs_dir/usr/bin/$gcc ]] || continue
        say "Found $(pq $gcc) on system"
        return 0
    done
    error "Could not find these versions of gcc: $(pq $kgcc $kalt)"
}

customize_firefox() {
    local pref_files file lang=${1%%.*}
    local string="user_pref(\"spellchecker.dictionary\","

    pref_files=$(ls $firefox_prefs 2>/dev/null)
    [[ -n $pref_files ]] || return
    sed -i "/$string/d" $pref_files
    sed -i '/"extensions.lastAppVersion"/ d' $pref_files
    for file in $pref_files; do
        echo "$string \"$lang\");" >> $file
    done
}

apt_get_packages() {
    local file=$1 label=$2
    shift 2
    local pkg_list cnt msg
    pkg_list=$(compile_pkg_list $file exclude-chroot)
    cnt=$(echo "$pkg_list" | wc -w)
    (( cnt == 0 )) && return

    local last_arg="${!#}"
    msg=$(plural $cnt "apt-get $last_arg $(pqn %n) $label package%s.")
    (( cnt >= 100 )) && msg="$msg  This could take some time."
    say "$msg"

    # First, simulate the installation to identify missing packages
    say "Simulating package installation to check availability..."
    local temp_output
    temp_output=$(mktemp)
    local simulation_output
    local missing_packages=""

    # Run simulation with -s flag
    echo "$pkg_list" | xargs apt-get $APT_GET_OPTS -s "$@" > "$temp_output" 2>&1
    simulation_output=$(cat "$temp_output")
    rm -f "$temp_output"

    # Parse simulation output to find missing packages
    missing_packages=$(echo "$simulation_output" | \
        grep -oE "Unable to locate package [^ ]+" | \
        awk '{print $NF}' | \
        sed "s/'//g")

    # Try alternative patterns for missing packages
    if [[ -z $missing_packages ]]; then
        missing_packages=$(echo "$simulation_output" | \
            grep -oE "Package [^ ]+ not available" | \
            awk '{print $2}' | \
            sed "s/'//g")
    fi

    # Try pattern for "has no installation candidate"
    local candidate_missing
    candidate_missing=$(echo "$simulation_output" | \
        grep -oE "Package '[^']+' has no installation candidate" | \
        sed "s/Package '\\([^']*\\)' has no installation candidate/\\1/")

    if [[ -n $candidate_missing ]]; then
        missing_packages="$missing_packages $candidate_missing"
    fi

    # Clean up missing packages list
    missing_packages=$(echo "$missing_packages" | tr ' ' '\n' | sort -u | tr '\n' ' ' | sed 's/^ *//;s/ *$//')

    # If there are missing packages, prompt user
    if [[ -n $missing_packages ]]; then
        local missing_cnt
        missing_cnt=$(echo "$missing_packages" | wc -w)
        say_in $high_co "$(plural $missing_cnt "$(pqw %n) $label package%s not available:")
$missing_packages"

        local available_packages="$pkg_list"
        # Remove missing packages from the list
        for missing_pkg in $missing_packages; do
            available_packages=$(echo "$available_packages" | sed "s/\b$missing_pkg\b//g" | sed 's/  */ /g' | sed 's/^ *//;s/ *$//')
        done

        local available_cnt
        available_cnt=$(echo "$available_packages" | wc -w)
        if (( available_cnt == 0 )); then
            error "No packages available for installation"
            return 1
        fi

        say "$(plural $available_cnt "$(pqw %n) package%s will be installed.")"
        YES_no "\nContinue with installation of available packages?" || my_exit
        pkg_list="$available_packages"
    fi

    local remaining_packages="$pkg_list"
    local failed_packages=""
    local attempt=1

    # Keep trying to install packages, removing problematic ones each time
    while [[ -n $remaining_packages ]]; do
        if (( attempt > 1 )); then
            local remaining_cnt
            remaining_cnt=$(echo "$remaining_packages" | wc -w)
            say "Attempt $attempt: trying to install remaining $remaining_cnt packages..."
        fi

        # Try to install current package list (with real-time output)
        local temp_output
        temp_output=$(mktemp)
        local exit_code

        # Run apt-get with tee to show output in real-time and capture to file
        echo "$remaining_packages" | xargs apt-get $APT_GET_OPTS "$@" 2>&1 | tee "$temp_output"
        exit_code=${PIPESTATUS[1]}

        # Read the captured output for error parsing
        local install_output
        install_output=$(cat "$temp_output")
        rm -f "$temp_output"

        if (( exit_code == 0 )); then
            # Success - all remaining packages installed
            break
        fi

        # Parse output to find which package couldn't be found
        local problem_pkg
        problem_pkg=$(echo "$install_output" | \
            grep -oE "Unable to locate package [^ ]+" | \
            head -1 | \
            awk '{print $NF}' | \
            sed "s/'//g")

        # If that didn't work, try alternative patterns
        if [[ -z $problem_pkg ]]; then
            problem_pkg=$(echo "$install_output" | \
                grep -oE "Package [^ ]+ not available" | \
                head -1 | \
                awk '{print $2}' | \
                sed "s/'//g")
        fi

        # Try pattern for "has no installation candidate"
        if [[ -z $problem_pkg ]]; then
            problem_pkg=$(echo "$install_output" | \
                grep -oE "Package '[^']+' has no installation candidate" | \
                head -1 | \
                sed "s/Package '\\([^']*\\)' has no installation candidate/\\1/")
        fi

        if [[ -z $problem_pkg ]]; then
            # Can't identify specific problem package, show error and exit
            echo "$install_output" >&2
            error "Package installation failed and couldn't identify problematic package"
            return 1
        fi

        say "Package '$problem_pkg' not found, removing from list and retrying..."
        failed_packages="$failed_packages $problem_pkg"

        # Remove the problematic package from remaining list
        remaining_packages=$(echo "$remaining_packages" | sed "s/\b$problem_pkg\b//g" | sed 's/  */ /g' | sed 's/^ *//;s/ *$//')

        attempt=$((attempt + 1))

        # Safety valve to prevent infinite loops
        if (( attempt > 50 )); then
            error "Too many package installation attempts, giving up"
            return 1
        fi
    done

    # Report any packages that couldn't be installed
    if [[ -n $failed_packages ]]; then
        local failed_cnt
        failed_cnt=$(echo "$failed_packages" | wc -w)
        # Clean up the failed packages list (remove leading/trailing spaces)
        failed_packages=$(echo "$failed_packages" | sed 's/^ *//;s/ *$//')
	say_in $high_co "$(plural $failed_cnt "$(pqw %n) $label package%s could not be found:")
	$failed_packages"
	error "Package installation completed with missing packages above"
    fi
}

install_packages() {
    local file=$1  label=$2
    shift 2
    apt_get_packages $file $label "$@" install
    check_missing $file "$label"
}

check_missing() {
    local pkg missing file=$1 label=$2 pkg_list cnt
    pkg_list=$(compile_pkg_list $file exclude-chroot)
    cnt=$(echo "$pkg_list" | wc -w)
    (( cnt == 0 )) && return

    local installed=/Build/installed-$label

    psay $cnt "Checking that $(pqn %n) $label package%s %were installed ..."

    dpkg --get-selections | grep "install\(ed\)\?$" | sed 's/\t.*//' > $installed.list
    for pkg in $pkg_list; do
        grep -q "^$pkg\(:[A-Za-z0-9+-]\+\)\?$" $installed.list || missing="$missing$pkg\n"
    done
    if [[ -z $missing ]]; then
        say "... Okay"
        return
    fi
    dpkg --get-selections  >  $installed.raw
    echo -e "$missing"     >  /Build/missing-$label.list

    local mcnt
    mcnt=$(echo -e "$missing" | wc -w)
    _say_ "$high_co------------------------------------------------$nc"
    _say_ "$(echo -e "$missing" | sed -e "s/^/$high_co/" -e "s/$/$nc/")"
    #_say_ "$(printf "$missing" | sed -e "s/^/$high_co/" -e "s/$/$nc/")"
    error "$(plural $mcnt "$(pqw %n) missing $label package%s")"
}

gather_deb() {
    local filt_arch filt_flav

    case $ISO_ARCH in
        x64) filt_arch="_i386\.deb$";;
        386) filt_arch="_amd64\.deb$";;
    esac

    case $ISO_RESPIN_OF in
        core) filt_flav="-base-\|-full-";;
        base) filt_flav="-core-\|-full-";;
        full) filt_flav="-base-\|-core-";;
    esac

    local dir f name deb_dir=$script_dir/Deb
    local flav=$ISO_RESPIN_OF
    for dir in $(flav_dirs $deb_dir); do
        for f in "$dir"/*.deb; do
            [[ -f $f ]] || continue
            [[ -n $filt_arch ]] && basename $f | grep -q -- "$filt_arch" && continue
            [[ -n $filt_flav ]] && basename $f | grep -q -- "$filt_flav" && continue
            echo $f
        done
    done
}

collect_live_files() {
    local list_file=$1 dest_dir=$sqfs_dir$2
    [[ -r $list_file ]] || return
    echo "Collecting Live-files"
    local list
    list="$(cat $list_file | grep -v "^\s*#\s*" | sed 's/\s*#.*//' \
        | grep "^/" | sed "s=^=$sqfs_dir=")"
    #echo "$list"

    $SUDO mkdir -p $dest_dir
    # This hard-codes the live-files dir but it is safer in case
    # $dest_dir is empty.
    $SUDO rm -rf "$(dirname $dest_dir)"/live-files/*

    local file dest
    # shellcheck disable=SC2086
    for file in $list; do
        [[ -e $file ]] || continue
        dest_file=${file#"$sqfs_dir"}
        dest=$dest_dir$dest_file
        $SUDO mkdir -p "$(dirname $dest)"
        $SUDO cp -a $file $dest
    done
}

#==============================================================================
# Routines for preparing and making the iso file
#==============================================================================

has_option() {
    local prog=$1 opt=$2
    $prog --help 2>&1 | grep -q -- "$opt\s"
    return $?
}

make_uefi_iso() {
    local prog=$1 uefi=$2  file=$3 dir=$4
    local cmd="$prog -l -V antiXlive -R -J -pad -no-emul-boot
    -boot-load-size 4  -boot-info-table -b boot/isolinux/isolinux.bin
    -eltorito-alt-boot $uefi boot/grub/efi.img -no-emul-boot
    -quiet -c boot/isolinux/isolinux.cat -o $file $dir"

    echo $cmd
    $cmd 2>&1 || error "iso file creation failed"
    isohybrid --uefi $file
}

make_xorriso_iso() {
    local prog=$1 file=$2 dir=$3
    local label="$DISTRO_NAME-Live"
    local opts_1="-hfsplus on -as mkisofs -quiet -l"

    local opts_2="-R -J -iso-level 3 -pad -partition_cyl_align on"
    opts_2="$opts_2 -c boot/isolinux/isolinux.cat"
    opts_2="$opts_2 -b boot/isolinux/isolinux.bin"
    opts_2="$opts_2 -no-emul-boot -boot-load-size 4 -boot-info-table"
    opts_2="$opts_2 -eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot"
    opts_2="$opts_2 -isohybrid-apm-hfsplus -isohybrid-gpt-basdat"

    cmd="$prog $opts_1 -V $label $opts_2 -o $file $dir"
    echo "$cmd"

    $cmd 2>&1 || error "iso file creation failed"
    isohybrid --uefi "$file"
}


unpack_gfx_cpio() {
    local type=$1  dir=${2:-$work_dir/$1-cpio}  file=${3:-$iso_dir/boot/$1/gfx-cpio}
    say "Unpack $(pq $type) cpio archive"
    prep_dir $dir
    (cd $dir && cpio -idum --dot --quiet < $file 2>&1)
}

repack_gfx_cpio() {
    local type=$1  dir=${2:-$work_dir/$1-cpio}  file=${3:-$iso_dir/boot/$1/gfx-cpio}
    say "Repack $(pq $type) cpio archive"
    (cd $dir && find . -depth | cpio -o --quiet --dot --file=$file) 2>&1
}

prep_dir() {
    local dir=$1
    [[ -z $dir || ! $dir =~ [a-zA-Z] ]] && fatal "Bad directory name: $dir"
    rm -rf $dir
    mkdir -p $dir
}

update_gfxboot_menu() {
    local menu_file=$1 conf_file=$2
    shift 2
    local subdir
    subdir="$(basename "$(dirname $conf_file)")"
    local menu_string="Function key menu"
    # Insert Function key menu into gfxboot.cfg
    [[ -e $menu_file && -e $conf_file ]] || return
    grep -q "$menu_string" "$conf_file" || return
    say "Update Fn key menu in $(pq $subdir/"$(basename $conf_file)")"
    sed -i "/$menu_string/,$ d" $conf_file
    cat << Fn_Menu >> $conf_file
; >>>>>>>>>> Function key menu >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
$(cat $menu_file)
$*
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Fn_Menu
}

#------------------------------------------------------------------------------
# Copy a 2nd kernel into iso/antiX/ and run live-multi-kernel
#------------------------------------------------------------------------------
copy_second_kernel() {
    local from_dir=$1  to_dir=$2
    local k0_name=vmlinuz  k1_name=vmlinuz1
    local vmlinuz=$to_dir/$k0_name
    local vmlinuz_1=$to_dir/$k1_name
    local version_prog=$tools/vmlinuz-version
    local lmk=$tools/live-multi-kernel

    ! [[ -d $from_dir ]]       && error "boot directory $from_dir not found"   && return 1
    ! [[ -d $to_dir ]]         && error "iso boot directory $to_dir not found" && return 1
    ! [[ -e "$vmlinuz" ]]      && error "File $vmlinuz not found"              && return 1
    ! [[ -x "$version_prog" ]] && error "Could not find program $version_prog" && return 1
    ! [[ -x "$lmk" ]]          && error "Could not find program $lmk"          && return 1

    local version_0 version_1
    version_0=$($version_prog -nr $vmlinuz  |grep vmlinuz| cut -d" " -f1)
    version_1=$($version_prog -nr $from_dir | grep vmlinuz| cut -d" " -f1 | { [[ -n $version_0 ]] && grep -v "^$version_0$" || cat; })

    case $(echo -n "$version_1" | grep -c .) in
        0) return ;;
        1)        ;;
        2) echo "$version_1"
           error "more then 2 vmlinuz1 kernels found"
           return ;;
    esac

    say "Found 2nd kernel $version_1"
    local k1
    [[ -n $version_1 ]] && k1=$($version_prog -n $from_dir | grep " $version_1 " | cut -d" " -f1) || k1=""
    say "copy $k1 $vmlinuz_1"
    cp $k1 $vmlinuz_1
    (cd $to_dir && md5sum $k1_name > $k1_name.md5)

    $lmk --distro="$DISTRO_NAME"
}

write_version_files() {
    local version_info_file=/etc/live/version/antiX
    mkdir -p "$(dirname $version_info_file)"
    write_version_info > $version_info_file

    echo "$fancy_name" > /etc/antix-version

    local rstring
    rstring="$(dd status=none if=/dev/urandom bs=1 count=40 2>/dev/null | md5sum | cut -d" " -f1)"
    local kernels=$K_NAME
    [[ -n $K_NAME2 ]] && kernels="$kernels $K_NAME2"
    local title=$LINUXFS_TITLE
    if [[ -z $title ]]; then
        title="Original $DISTRO_NAME $DISTRO_VERSION $ISO_ARCH"
        [[ $DISTRO_NAME =~ ^antiX && -n $FLAV ]] && title="$title $FLAV"
    fi
    local linuxfs_version_file=/etc/live/version/linuxfs.ver
    mkdir -p "$(dirname "$linuxfs_version_file")"
    cat > "$linuxfs_version_file" << Linuxfs_Version
=== $rstring

title: $title
creation date: $(printf '%(%e %B %Y %T %Z)T' -1)
kernel: $kernels
inxi version: $fancy_name
Linuxfs_Version

}

write_version_info() {
    cat << Version-Info
Distro name:$DISTRO_NAME
Version:$DISTRO_VERSION
antiX flavour:$ISO_FLAV
Kernel:$K_NAME
Code name:$CODE_NAME
Release date:$RELEASE_DATE
Made by:$ME version $VERSION ($VERSION_DATE)
Version-Info
}

write_initrd_release() {
    local dir=$1  sudo=$2  name=initrd_release
    [[ ${#dir} -eq 0 ]] && fatal "Empty directory passed to write_initrd_version()"

    local DISTRO_BASE="antiX"
    is_antiX || DISTRO_BASE="MX"

    local file1=$dir/etc/$name  file2=$dir/etc/live/version/$name
    $sudo mkdir -p "$(dirname $file1)" "$(dirname $file2)"

    : ${ASCII_CODE_NAME:="$(echo "$CODE_NAME" | utf8_to_ascii)"}

    if [[ $ASCII_CODE_NAME != "$CODE_NAME" ]]; then

        cat << Initrd_Version | $sudo tee $file1
NAME="$DISTRO_NAME"
VERSION="$DISTRO_VERSION ($CODE_NAME)"
ASCII_VERSION="$DISTRO_VERSION ($ASCII_CODE_NAME)"
ID="$(echo $DISTRO_NAME | tr '[:upper:]' '[:lower:]')"
VERSION_ID="$(echo $DISTRO_VERSION | sed -r 's/^([0-9._-]+).*/\1/')"
PRETTY_NAME="$DISTRO_NAME $DISTRO_VERSION ($CODE_NAME)"
ASCII_PRETTY_NAME="$DISTRO_NAME $DISTRO_VERSION ($ASCII_CODE_NAME)"
ANSI_COLOR="0;34"
HOME_URL="$HOME_URL"
BUG_REPORT_URL="$BUG_REPORT_URL"
BASE=$DISTRO_BASE
Initrd_Version

    else

        cat << Initrd_Version | $sudo tee $dir/etc/initrd_release
NAME="$DISTRO_NAME"
VERSION="$DISTRO_VERSION ($CODE_NAME)"
ID="$(echo $DISTRO_NAME | tr '[:upper:]' '[:lower:]')"
VERSION_ID="$(echo $DISTRO_VERSION | sed -r 's/^([0-9._-]+).*/\1/')"
PRETTY_NAME="$DISTRO_NAME $DISTRO_VERSION ($CODE_NAME)"
ANSI_COLOR="0;34"
HOME_URL="$HOME_URL"
BUG_REPORT_URL="$BUG_REPORT_URL"
BASE=$DISTRO_BASE
Initrd_Version

    fi

    $sudo cp $file1 $file2
}

utf8_to_ascii() {
    iconv -f utf-8 -t ascii//translit
}

busybox_depmod() {
    local targ=$1  kernel=$2  cmd=${3:-depmod}

    local mod_dir=$targ/lib/modules
    local k_dir=$mod_dir/$kernel
    local to_delete

    [[ -d $targ ]]             || fatal "Target $targ is not a directory"
    [[ -x $targ/bin/busybox ]] || fatal "Could not find /bin/busybox"
    [[ -x $targ/bin/$cmd ]]    || fatal "Could not find /bin/$cmd"
    [[ -d $mod_dir ]]          || fatal "Could not find /lib/modules"
    [[ -d $k_dir ]]            || fatal "Could not find $k_dir"

    local proc_dir=$targ/proc
    if ! [[ -e $proc_dir ]]; then
        mkdir $proc_dir
        to_delete="$proc_dir $to_delete"
    fi

    touch $proc_dir/modules

    fake_dir=$mod_dir/$(uname -r)
    if [[ $fake_dir != "$k_dir" ]]; then
        ln -s $kernel $fake_dir || error "Error creating $fake_dir symlink"
        to_delete="$fake_dir $to_delete"
    fi

    $SUDO chroot $targ /bin/depmod
    for file in $to_delete; do
        echo "delete $file"
        rm -r $file
    done

    depmod_file=$k_dir/modules.dep.bb
    [[ -e $depmod_file ]] || error "The modules.dep.bb file was not created"

    $SUDO chown $USER $depmod_file
}

#==============================================================================
# Chroot related routines
#==============================================================================
do_chroot() {
    (( stage >= 1 )) || fatal "Not ready to do chroot"

    prep_chroot
    say "Enter chroot for $(pq $full_distro_name)"
    $SUDO chroot $sqfs_dir /bin/bash --rcfile /Build/bashrc
    say "Leave chroot"
    umount_chroot
    return 0
}

#------------------------------------------------------------------------------
# mount_deb_cache
# Bind mount the .deb cache directory outside the chroot so we can reuse all
# .debs that have been downloaded. This is MUCH more efficent than simply
# deleting them.
#------------------------------------------------------------------------------
mount_deb_cache() {
    local deb_dir=$sqfs_dir/var/cache/apt/archives
    mkdir -p $deb_cache_dir
    bind_mount $deb_cache_dir $deb_dir
}

#------------------------------------------------------------------------------
# bind_mount old_mp new_mp
# Common code for bind outside mounting directories in the chroot.
#------------------------------------------------------------------------------
bind_mount() {
    local old=$1 new=$2
    mountpoint -q $new && return
    $SUDO mkdir -p $new
    $SUDO mount --bind $old $new  || my_exit
    UMOUNTS="$new $UMOUNTS"
}

#------------------------------------------------------------------------------
# prep_chroot
# Mount /proc /sys and /var/cache/apt/archives in the chroot. Offer to also
# mount /dev if it appears to be empty. Create and populate the /Build dir
# in the chroot if it does not already exist. Otherwise don't touch it.
#------------------------------------------------------------------------------
prep_chroot() {
    check_sqfs_dir
    umount_chroot
    mount_deb_cache

    for fs in proc sys; do
        say "Mounting $(pq /$fs) in chroot"
        if ! bind_mount /$fs $sqfs_dir/$fs; then
            error "Failed to mount $(pq /$fs) in chroot"
            my_exit
        fi
        say "Successfully mounted $(pq /$fs)"
    done

    if ! [[ -e $sqfs_dir/dev/tty ]]; then
        say "Mount $(pq /dev) in the chroot"
        bind_mount /dev $sqfs_dir/dev
    fi

    if ! mountpoint -q $sqfs_dir/dev/pts; then
        say "Mount $(pq /dev/pts) in the chroot"
        bind_mount /dev/pts $sqfs_dir/dev/pts
    fi

    [[ -e $sqfs_dir/Build ]] || make_build_dir

    if ! is_antiX && [[ ! -f $sqfs_dir/etc/resolv.conf ]]; then
        $SUDO cp -H /etc/resolv.conf $sqfs_dir/etc/resolv.conf
    fi

    # Always use local mirror when working in chroot
    set_chroot_mirror $LOCAL_MIRROR "LOCAL mirror"

    # TERM helps nano to work in chroot, LC_ALL is for Deb
    export TERM=xterm LC_ALL=C
}

#------------------------------------------------------------------------------
# make_build_dir
# Create a Build/ subdirectory in the work directory. Populate it with all
# the programs and data needed to run ourselves in the chroot environment then
# move the entire directory into the chroot.
# Populate it with;
#     Ourselves
#     Deb/$ISO_ARCH-$FLAV for .deb files
#     DEFAULTS file and contents of Output/
#     Tools/ directory
#     Most of the Template/
#     ENV_IN, bashrc, and bashrc2 files
#
# A bind mount would be much simpler.
#------------------------------------------------------------------------------
make_build_dir() {

    local b_dir=$work_dir/Build
    rm -rf $b_dir
    mkdir $b_dir

    mkdir -p $b_dir/Deb
    local deb_files
    deb_files=$(gather_deb)
    [[ -n $deb_files ]] && cp --target-directory=$b_dir/Deb $deb_files

    cp -r $0 Input $tools $regex_files $b_dir

    #make custom user-defaults file defaults in chroot, if it exists and switch was used
    if [[ -n $user_defaults ]]; then
        cp $user_defaults $b_dir/Input/defaults
    fi

    mkdir $b_dir/Output
    touch $b_dir/$partial_name $b_dir/Output/$ME.log

    cp $output_dir/stage-?.out $b_dir/Output

    local cmd
    mkdir -p $b_dir/fake
    for cmd in $DUMMY_SERVICES; do
        ln -s /bin/true $b_dir/fake/$cmd
    done

    # This skips the larger subdirectories which aren't needed
    (cd $script_dir && tar cf -          \
        --exclude iso                    \
        --exclude initrd                 \
        --exclude squashfs               \
        --exclude isolinux               \
        Template)                        \
        | (cd $b_dir && tar xBf -)

    [[ -n $THEME ]] && copy_theme_dir $b_dir

    # Let chroot user over-ride values set by host system
    cat << Env_In > $b_dir/ENV_IN
: \${ASK_PART:=$ASK_PART}
: \${EXIT_PART:=$EXIT_PART}
: \${RUN_PART:=$RUN_PART}
: \${SHELL_PART:=$SHELL_PART}
: \${SKIP_PART:=$SKIP_PART}
: \${TEST_PART:=$TEST_PART}
Env_In

    local lt_blue="\e[1;34m" lt_green="\e[1;32m" lt_red="\e[1;31m" nc="\e[0m"

    cat << Bashrc > $b_dir/bashrc
source ~/.bashrc
alias ls="ls --color=auto -F"
alias ll="ls --color=auto -lhF"
alias la="ls --color=auto -FA"
PS1="${lt_blue}chroot${lt_green}>$nc "
Bashrc

    cat << Bashrc2 > $b_dir/bashrc2
source /Build/bashrc
PS1="${lt_blue}breakpoint${lt_green}>$nc "
Bashrc2

    $SUDO rm -rf $sqfs_dir/Build
    $SUDO mv $b_dir $sqfs_dir
}

copy_theme_dir() {
    [[ -z $THEME || $THEME = none ]] && return
    local b_dir=$1 t_dir=$theme_dir/$THEME
    if [[ ! -d $t_dir ]]; then
        # shellcheck disable=SC2046
        error "Theme directory $(pqw \"$(short_dir \"$t_dir\")\") does not exist"
        return
    fi
    local b_theme_dir
    b_theme_dir=$b_dir/"$(basename $theme_dir)"
    mkdir -p $b_theme_dir/$THEME
    cp -a $t_dir/* $b_theme_dir/$THEME/
    cp -a $theme_dir/*.sh $b_theme_dir/
}

#------------------------------------------------------------------------------
# umount_chroot
# Umount all fileystems mounted under any work/squashfs directory under the
# true Remaster directory. For each such mountpoint we try umounting it up to
# four times before giving up. If any such mountpoint is still a mountpoint
# after four attempts to umount it then we error out at the end of the routine.
#------------------------------------------------------------------------------
umount_chroot() {
    for mp in $(mount | cut -d" " -f3 | grep "^$remaster_dir/work/.*/squashfs/"); do
        local name=${err_co}chroot:$bold_co${mp##"$remaster_dir"/*/squashfs}

        # Don't umount the tmpfs
        [[ $mp == "$sqfs_dir" ]] && continue

        $SUDO umount -l $mp 2>/dev/null

        for _ in 1 2 3; do
            mountpoint -q $mp || break
            say "umount $name"
            $SUDO umount -l $mp
            mountpoint -q $mp || break
            sleep 1
        done

        mountpoint -q $mp || continue
        warn "Still could not umount $name"
        UMOUNT_ERRORS=true
    done

    [[ -n $UMOUNT_ERRORS ]] && fatal "Umount errors!"
}

#------------------------------------------------------------------------------
# We do this outside of the chroot so we know for sure it is set correctly
# before running mksquashfs. We want it to always be local when running in
# the chroot and always be the real MIRROR when running mksquashfs.
#------------------------------------------------------------------------------
set_chroot_mirror() {
    local mirror=$1; shift
    [[ -n $mirror ]] || return

    local file=$sqfs_dir/etc/apt/sources.list.d/debian.list
    [[ -f $file ]] || return

    say "Set apt mirror to $* $(pq $mirror)"
    $SUDO sed -i "s=/ftp\.\(..\.\)\\?debian\.org/=/ftp.$mirror.debian.org/=" $file
}

#==============================================================================
# General Utilities
#==============================================================================
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
du_size() { $SUDO du --one-file-system -sh $1 | cut -f1 | sed 's/^\s\+//'; }

convenience_link() {
    local dir=$1 link=$2 label=${3:-$2}
    [[ -z $link ]] && error "No link passed to convenience_link()" && return

    mkdir -p $dir || error "Could not create $label dir $(pqw $dir)"
    rm -f $script_dir/$link
    ln -sf $dir $script_dir/$link
}

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
report_size() {
    local name size
    name=$(basename $1)
    size=$(du_size $1)
    say "size of $name dir: $(pqn $size)"
}

#------------------------------------------------------------------------------
# check_sqfs_dir
# Mostly needed during development to prevent bad things from happening.
#------------------------------------------------------------------------------
check_sqfs_dir() {
    local dir=${1:-$sqfs_dir}

    echo $dir | grep -q "^$remaster_dir/work/.*/squashfs" \
        || fatal "Suspicous sqfs_dir in stage $stage: <$(pqw $dir)>"

    [[ -d $dir ]] || fatal "sqfs_dir does not exist! in stage: $stage"
}

#------------------------------------------------------------------------------
# has_word var_name part
# See if the word "part" is incuded in the comma separated list of words in the
# variable called "name". Also return true if the words "a" or "all" are in
# the string.
#------------------------------------------------------------------------------
has_word() {
    local name=$1 part=$2
    eval val=\$$name
    case ,$val, in
            *,$part,*) return 0 ;;
        *,a,*|*,all,*) return 0 ;;
                    *) return 1 ;;
    esac
}

#------------------------------------------------------------------------------
# strip_color
# A simple filter to strip out the ANSI colors we use.
#------------------------------------------------------------------------------
strip_color() { sed -r 's/\x1b\[[0-9;]+[mK]//g'; }

cprint_left() {
    local width=$1 str=$2
    local pad
    pad=$((width - $(str_len "$str")))
    printf "%s%${pad}s" "$str" ""
}

cprint_right() {
    local width=$1 str=$2
    local pad
    pad=$((width - $(str_len "$str")))
    printf "%${pad}s%s" "" "$str"
}

str_len() {
    local msg_nc
    msg_nc=$(echo "$*" | sed -r -e 's/\x1b\[[0-9;]+[mK]//g' -e 's/./x/g')
    echo ${#msg_nc}
}

short_dir() {
    local dir=$1  pre=${2:-$script_dir}
    echo "${dir#"$pre"/}"
}


#==============================================================================
# Timer Routines
#==============================================================================
start_timer() {
    local name=${1:-START_T}
    eval $name=\"$EPOCHSECONDS\"
}

end_timer() {
    _end_timer_ START_T "$@"
}

_end_timer_() {
    local name=$1 title
    title=$(cprint_left 36 "$2")
    eval local start_t=\$$name
    # shellcheck disable=SC2154
    echo  # Ensure we start on a fresh line
    _say_ "${time_co}time for $text_co$title$nc $(pqn "$(elapsed $start_t)")$nc"
}

elapsed() {
    local secs mins hours start_time current_time
    start_time=${1:-0}
    current_time=$EPOCHSECONDS

    # Validate timestamps and calculate safely
    if [[ ! "$start_time" =~ ^[0-9]+$ ]] || (( start_time <= 0 )); then
        printf "%8d %s\n" 0 "secs"
        return
    fi

    secs=$((current_time - start_time))

    # Handle negative or invalid time differences
    if (( secs < 0 )); then
        printf "%8d %s\n" 0 "secs"
        return
    fi

    (( secs < 60 )) && printf "%8d %s\n" $secs "$(plural $secs "sec%s")" && return
    mins=$((secs / 60))
    secs=$((secs - 60 * mins))
    (( mins < 60 )) && printf "%5d:%02d mm:ss\n" $mins $secs && return
    hours=$((mins / 60))
    mins=$((mins - 60 * hours))
    printf "%2d:%02d:%02d hh:mm:ss\n" $hours $mins $secs
}

#==============================================================================
# Cache Routines
#==============================================================================
#------------------------------------------------------------------------------
# create_cache  type subtype dir
# restore_cache type subtype dir
#
# Each cache is identified by "type-subtype". The purpose of this split is to
# allow the user to turn caching on and off by type although right now the
# only type is "debootstrap".
#
# _cache_() contains common intro code for create_cache() and restore_cache().
#------------------------------------------------------------------------------
create_cache()  { _cache_ create  "$@"; }
force_cache()   { _cache_ force   "$@"; }
restore_cache() { _cache_ restore "$@"; }
was_cached()    { _cache_ was     "$@"; }

_cache_() {
    local ctype=$1; shift
    local type=$1 subtype=$2 dir=$3

    local cache_exclude="^/Build|^/proc/|^/sys/|^/var/cache/apt/archives/"

    echo $dir | grep -q "^$remaster_dir" || fatal "Refusing to cache suspicious directory: $dir"

    case ,$CACHE, in
        *,$type,*) ;;
                *)  say "Skipping cache type $(pq $type)"
                    return 1;;
    esac

    local cache_dir=$remaster_dir/cache
    mkdir -p $cache_dir
    local ext=.cpio.gz
    local name=$type-$subtype
    local file=$cache_dir/$name$ext

    if [[ $ctype = was ]]; then
        [[ -e $file ]]
        return $?
    fi

    local short
    short=$(short_dir $cache_dir)
    if [[ -n $CACHE_EXPIRE ]] && (( CACHE_EXPIRE > 0 )); then
        #vsay "Find $(pqn $ext) files to expire in $(pq $short)"
        local expire
        expire=$(find $cache_dir -name "*$ext" -ctime +$CACHE_EXPIRE)
        for e in $expire; do
            say "Expire:$bold_co $(basename $e $ext)$nc"
        done
        [[ -n $expire ]] && YES_no "Expire these files" \
            && find $cache_dir -name "*$ext" -ctime +$CACHE_EXPIRE -delete
    fi

    case $ctype in
    restore)
        [[ -e $file ]] || return 1
        say "Found cache $(pq $name$ext)"
        YES_no "Restore from this cache" || return 1

        if [[ -d "$dir" && "$(find "$dir" -mindepth 1 -maxdepth 1 -print -quit 2>/dev/null)" ]]; then
            say "Clear out existing files"
            find "$dir" -mindepth 1 -delete
        fi
        mkdir -p $dir

        say "Restore $(pq $type $subtype) from cache"
        start_timer
        (cd $dir && gunzip -c $file | $SUDO cpio -idum --quiet)
        end_timer "Restore cache"
        say "Restored $(pqn "$(du_size $dir)") bytes of data"
        ;;

    create|force)

        say "Create cache of $(pq $type $subtype)"

        if [[ -e $file ]]; then
            [[ $ctype = create ]] && return 1
            YES_no "Overwrite exiting cache file?" || return 1
        fi

        [[ -d $dir ]] || fatal "Can't cache a non-existent directory: $dir"
        mkdir -p $cache_dir

        # This prevents us from prompting for the password two
        # time simultaneously inside the parens below.
        $SUDO echo >/dev/null
        start_timer

        (cd $dir && $SUDO find . -depth | grep -vE "$cache_exclude" \
            | $SUDO cpio -oa -H newc --quiet | $GZIP -3) > $file

        end_timer "Create cache"
        ;;
    *)
        fatal "Unknown _cache_ type: $ctype"
        ;;
    esac
    return 0
}

#==============================================================================
# Printing, Logging and yes/no question
#==============================================================================

vexit()  { _say_ "${bold_co}Exit:$nc $*";         my_exit 0 ;}
warn()   { _say_ "${bold_co}Warning:$bold_co $*$nc"         ;}
say2()   { echo; say "$*"                                   ;}
say()    { _say_ "$text_co$*$nc"                            ;}
psay()   { say "$(plural "$@")"                             ;}
yell()   { _say_ "$bold_co$*$nc"                            ;}
vsay()   { [[ -n $verbose_mode ]] && say "$*"               ;}
nqsay()  { [[ -z $quiet_mode ]] && say "$@"                 ;}

pqh()    { echo "$text_co$*$high_co"  ;}
pqnh()   { echo "$num_co$*$high_co"   ;}
pq()     { echo "$high_co$*$text_co"  ;}
pqn()    { echo  "$num_co$*$text_co"  ;}
pqw()    { echo "$text_co$*$bold_co"  ;}
pqnw()   { echo  "$num_co$*$bold_co"  ;}

say_fmt() {
    local lab=$1 val=$2
    local fmt
    fmt="%15s:$(pqn %5s) meg\n"
    # shellcheck disable=SC2059
    say "$(printf "$fmt" "$lab" "$val")"
}

say_in() {
    local color=$1  msg=$2
    _say_ "$(echo "$msg" | sed -e "s/^/$color/" -e "s/$/$nc/")"
}

_say_() {
    echo -e "$*"
    [[ -n $log_file ]] && echo -e "$*" >> $log_file
}

error()  {
    _say_ "${err_co}Error:$bold_co $*$nc"

    YES_no "Ignore this error" || my_exit 1
    say "Error ignored"
    return 0
}

fatal()  {
    _say_ "${err_co}Fatal Error:$bold_co $*$nc"
    my_exit 1
}


#------------------------------------------------------------------------------
# echo a command to the sceeen and the log file then run it
#------------------------------------------------------------------------------
cmd() {
    _say_ " > $*"
    "$@"
}
#------------------------------------------------------------------------------
# plural cnt string
# Do simple substition on <string> to match the <cnt>. May need more entries
# but the current set suffices for now.
#------------------------------------------------------------------------------
plural() {
    local n=$1 str=$2
    case $n in
        1) local s='' ies=y   are=is   were=was  es=;;
        *) local s=s  ies=ies are=are  were=were es=es;;
    esac
    echo "$str" | sed -e "s/%s\>/$s/g" -e "s/%ies\>/$ies/g" \
        -e "s/%are\>/$are/g" -e "s/%n\>/$n/g" -e "s/%were\>/$were/g" \
        -e "s/%es\>/$es/g" -e "s/%3d\>/$(printf "%3d" $n)/g"
}

#------------------------------------------------------------------------------
# A collection of routines to ask Yes/No questions. The default is in upper
# case. The *_loud versions ignore quiet_mode.
#------------------------------------------------------------------------------
YES_no()      { _yes_no_  0  0  "(Y/n)"  "$1"; }
yes_NO()      { _yes_no_  1  1  "(y/N)"  "$1"; }
yes_no_loud() { _yes_no_ -1 -1 "((y/n))" "$1"; }
YES_no_loud() { _yes_no_ -1  0 "((Y/n))" "$1"; }
yes_NO_loud() { _yes_no_ -1  1 "((y/N))" "$1"; }

#------------------------------------------------------------------------------
# _yes_no_ quiet_ret default_ret yn_prompt prompt
# Immediately return quiet_ret if it is greater or equal to zero and we are in
# quiet_mode. Return default_ret if the empty string is given and default_ret
# is greater than or equal to zero. Otherwise return true on yes and false on
# no.
#------------------------------------------------------------------------------
_yes_no_() {
    local ans quiet_ret=$1 def_ret=$2 yn=$3 prompt=$4

    [[ -n $quiet_mode ]] && (( quiet_ret >= 0 )) && return $quiet_ret

    while true; do
        echo -ne "$text_co$prompt$prompt_co $yn?$nc "
        read -r ans
        case x$ans in
            x[Yy]*) return 0;;
            x[Nn]*) return 1;;
                 x) (( def_ret >= 0 )) && return $def_ret;;
        esac

        [[  -z $ans ]] && echo -n 'You must answer "y" or "n".  '
        [[  -n $ans ]] && echo "bad answer: <$ans>"
        echo "Please try again"
    done
}

#==============================================================================
# Usage Routines
#==============================================================================
show_stages() {
    echo -e "${bold_co}The stages of processsing:$nc\n"
    while read -r num title; do
        printf " $bold_co%2d$nc. $text_co%s$nc\n" "$num" "$title"
    done << Extract_Stages
$(sed -r -n "s/^\s*enter_stage\s*([0-9]+)\s*\"[!]?([^\"]+)\".*/\1 \2/p" $0)
Extract_Stages

    cat << Stages_Blurb

There is limited control over running stages with the following environment
variables. Each variable can be set to a comma delimited list of stages
it applies to. Put "a" or "all" in a list to have it apply to all stages.

${text_co}  ASK_STAGE$nc Ask before running stage
${text_co} EXIT_STAGE$nc Exit right *before* running stage
${text_co} SKIP_STAGE$nc do not run stage

Stages_Blurb
}

show_parts() {
    echo -e "${bold_co}The parts within stage-4:$nc\n"
    while read -r num title; do
        printf " $bold_co%2d$nc. $text_co%s$nc\n" "$num" "$title"
    done << Extract_Parts
$(sed -r -n 's=^\s.*do_part\s+([0-9]+)\s+"[!]?([^"]+)".*=\1 \2=p' $0)
Extract_Parts

    cat << Parts_Blurb

The running of each part can be controled by the following environment
variables. Each variable can be set to a comma delimited list of parts
it applies to. Put "a" or "all" in a list to have it apply to all parts.
Ranges are allowed such as in SKIP_PART=1-7,9,11

${text_co}  ASK_PART$nc Ask before doing part
${text_co} EXIT_PART$nc Exit *after* doing part
${text_co}  RUN_PART$nc Do the part even if it is in SKIP_PART
${text_co}SHELL_PART$nc Open a shell before doing the part
${text_co} SKIP_PART$nc Skip doing the part
${text_co} TEST_PART$nc If this list contains a digit then only do
           the parts on the list and skip all others
Parts_Blurb
}

expand_parts() {
    local val var
    for var; do
        eval "val=\${$var:-}"
        [[ $val =~ - ]] || continue
        val=$(expand_range "$val")
        eval "$var=\$val"
    done
}

expand_range() {
    local range
    range="$(_expand_range_ "$1")"
    echo "${range// /,}"
}

_expand_range_() {
    for p in ${1//,/ }; do
        if ! echo $p | grep -Eq "^[0-9]+-[0-9]+$"; then
            echo "$p"
            continue
        fi
        local first last
        first=$(echo $p | cut -d- -f1)
        last=$(echo $p | cut -d- -f2)
        seq $first $last
    done
}

#==============================================================================
# Routines used in stage-0
#==============================================================================
#------------------------------------------------------------------------------
# choose prompt var_name choice-1 choice-2 ...
# Multiple choice. If the variable is already defined (usually in the DEFAULTS
# file) then we do nothing. If the variable is in the DEFAULTS file then offer
# to update the default in DEFAULTS.
#------------------------------------------------------------------------------
choose() {
    local value title=$1 var=$2;
    shift 2;

    eval value=\$$var
    [[ -n $value && -z $reset_mode ]] && return

    local prompt="${err_co}Enter a number$prompt_co>$nc "
    echo
    [[ -n $value ]] && say "Current $(pq $title) default: $(pq $value)"

    my_select "Select $title:" "$prompt" value "$@"

    # Strip first " (" and all that follows it (for ENABLE_LOCALES)
    # Quite a kludge but it seems to work okay.
    value=${value%% (*}
    eval $var=\$value

    update_default_file $var "$value"
}

my_select() {
    local title=$1 prompt=$2 var=$3;
    shift 3

    local data display lab cnt=0
    for lab; do
        cnt=$((cnt+1))
        data="${data}$cnt:$lab\n"
        display="${display}$(printf "%2d) %s" $cnt "$lab")\n"
    done

    local val input
    while [[ -z $val ]]; do

        # shellcheck disable=SC2059
        printf "%s" "$bold_co$title$nc\n"
        # shellcheck disable=SC2059
        printf "%s" "$display" | column | sed -r "s/(^|\t)( ?[0-9]+)/\t$green\2$nc/g"
        # shellcheck disable=SC2059
        printf "%s" "$prompt"

        read -r input
        if [[ -z $input ]] || ! echo "$input" | grep -q "^[0-9]\+$"; then
            echo "You must input a number"
            continue
        fi

        val=$(echo -e "$data" | sed -n "s/^$input://p")

        if [[ -z $val ]]; then
            echo  "Input out of range"
            continue
        fi

        eval $var=\"$val\"
        break
    done
}

#------------------------------------------------------------------------------
# update_default var_name
#------------------------------------------------------------------------------
update_default() {
    local value var=$1
    eval value=\$$var
    local orig_val=$value
    [[ -n $value && -z $reset_mode ]] && return
    echo -e "\n${text_co}Update default $(pq $var): $orig_val$nc"
    [[ -n $orig_val ]] && YES_no "Use current default" && return

    while true; do
        echo -n "Enter new default> "
        read -r value
        echo
        : ${value:="$orig_val"}
        if echo "$value" | grep -q '["\\$]'; then
            warn "Removing [\"\\\$] characters"
            # Remove all occurrences of " \ $
            value=${value//['"\$']/}
        fi
        if [[ -z $value ]]; then
            echo "Empty values are not allowed without an existing default."
            continue
        fi
        YES_no "Is \"$(pq "$value")\" correct" && break
    done
    [[ $value != "$orig_val" ]] && update_default_file $var "$value"
}


update_default_file() {
    local file  short var=$1  value=$2

    for file in $(reverse $all_defaults); do
        grep -q "^\s*$var=" $file || continue
        short=$(short_dir $file)
        #YES_no "\nDo you want to save $var ($(pq "$value")) in $(pq $short)" || return
        sed -r -i "s/^(\s*$var=).*/\1\"$value\"/" $file
        say "Saved $(pq "$var=\"$value\"") in file $(pq $short)"
        break
    done
}

reverse() {
    local x final
    for x; do
        final="$x $final"
    done
    echo "$final"
}

load_defaults() {
    local file short
    for file in $all_defaults; do
        short=$(short_dir $file)
        [[ -r $file ]] || fatal "No $(pqw $short) file found."
        # shellcheck disable=SC1090
        source $file
    done
}

pick_prog() {
    local prog found var=$1
    shift
    eval $var=
    for prog; do
        which $prog &>/dev/null || continue
        eval $var=\$prog
        found=true
        break
    done
    [[ -n $found ]] || error "Could not find any of these programs: $(pqw "$@")"
}

select_theme() {
    local themes dir
    for dir in "$theme_dir"/*; do
        [[ -d $dir ]] && themes="$themes $(basename $dir)"
    done

    [[ -n $themes ]] || return
    yes_NO_loud "Do you want to set a theme" || return
    choose "Select a theme" THEME $themes
}

check_theme_dir() {
    local theme=${1:-$THEME}
    [[ -z $theme || $theme = none ]] && return
    [[ -d $theme_dir/$THEME ]] \
        || error "The theme directory $(pqw sort_dir $theme_dir/$THEME) does not exist"

}

#==============================================================================
# Overall Flow Control
#==============================================================================
#------------------------------------------------------------------------------
# clear_outputs [stop_stage]
# Clear all the output files. If there is a work directory available, move
# them there, otherwise, erase them. Prompt before doing either. If we are
# in pretend_mode then say what would happen without doing anything.
# If stop_stage is provided then we stop after clearing that stage. Since
# we work in reverse order, this implements a "redo" feature.
#
# Return failure only if user says no to clearing files.
#------------------------------------------------------------------------------
clear_outputs() {
    local names files stop=${1:-0} pretend=$2 delete=$3
    for i in $(reverse $all_stages); do
        (( i < stop )) && break
        local name=stage-$i.out
        local file=$output_dir/$name
        [[ -f $file ]] || continue
        names="$names$name\n"
        files="$files $file"
    done
    local col_names
    col_names=$(echo -e "$names" | sort | column -c 78 | expand \
        | sed -e "s/^/$high_co/" -e "s/$/$nc/")

    [[ -n $files ]] || return 0

    if [[ -n $pretend ]]; then
        echo -e "$ME would clear:\n$col_names\n"
        return 0

    elif [[ -n $delete ]]; then
        rm -f $files
        return 0

    else
        nqsay "Output files to be cleared:\n$col_names"

        YES_no "Remove these output files" || return 1

        if [[ -n $work_dir && -d $work_dir ]]; then
            #nqsay "Save:\n$col_names"
            local save_out=$work_dir/Output
            mkdir -p $save_out
            mv -f $files $save_out/
        else
            #nqsay "Delete:\n$col_names"
            rm -f $files
        fi
    fi
    return 0
}

my_exit() {
    local ret=${1:-0}
    echo $ret > $exit_file
    exit $ret
}

#------------------------------------------------------------------------------
# do_pretend
# Report what the next stage to work on would be. Also display the name of
# the stage and the global variables (if appropriate). BUG: there are cases
# where the globals aren't 100% accurate if redo_mode or start_from are used.
#------------------------------------------------------------------------------
do_pretend() {
    #[[ -n $redo_mode && $stage -gt 0 ]] && stage=$((stage - 1))
    #[[ -n $start_from && $stage -gt $start_from ]] && stage=$start_from

    echo "$ME would next do stage: $bold_co$stage$nc"

    local stage_info
    [[ -n $stage ]] && stage_info=$(grep -m 1 "^\s\+enter_stage\s\+$stage" $0\
        | sed -r "s/^\s*enter_stage\s*$stage\s*\"[!]?([^\"]+)\".*/    \1/") || stage_info=""

    [[ -n $stage_info ]] && echo -e "$text_co$stage_info$nc"

    #[[ $stage -lt 1 || -n $quiet_mode ]] && return 0
    if [[ -z $quiet_mode ]]; then
        echo -e "\nUsing this information:"
        echo
        pretty_output $stage
    fi

    if (( stage > 0 )); then
        echo
        do_one_stat
    fi
    return 0
}

do_stats() {
    local flavs="mx32 mx64 mxahs mxkde"
    is_antiX && flavs="core base full"
    for FLAV in $flavs; do
        ISO_RESPIN_OF=$FLAV
        yell "\n$FLAV$high_co:"
        do_one_stat
    done

    local regex="core|base|full"
    ! is_antiX && regex="$regex|mx32|mx64|mxahs|mxkd"
    for FLAV in $(flavour_list | grep -Ev "^($regex)$"); do
        for ISO_RESPIN_OF in core full; do
            yell "\n$FLAV/$ISO_RESPIN_OF$high_co:"
            do_one_stat
        done
    done
    _say_
    exit
}

do_one_stat() {
    if [[ -n $verbose_mode ]]; then
        gather_say exclude-bootstrap  "    $(pqn %3d) excluded (bootstrap) package%s"
        gather_say exclude-chroot     "    $(pqn %3d) excluded (chroot)    package%s"
        gather_say basic-package      "    $(pqn %3d) basic                package%s"
        gather_say pesky-package      "    $(pqn %3d) pesky                package%s"
        gather_say package            "    $(pqn %3d) antiX                package%s"
        gather_say remove             "    $(pqn %3d) remove               package%s"
        gather_say add                "    $(pqn %3d) add                  package%s"
        gather_say reinstall          "    $(pqn %3d) reinstall            package%s"
    else
        gather_say package            "    $(pqn %3d) antiX                package%s"
    fi
    local pkg_count
    pkg_count=$(gather_cnt package)
    # TMPFS_SIZE format: "fixed + per_package" both in 100KB units
    # Need to evaluate: (2500 + 70 * pkg_count) / 10 to get MB
    local needed
    needed=$(((2500 + 70 * pkg_count) / 10))
    # shellcheck disable=SC2059
    say "$(printf "size of tmps: $(pqn %6d) MB\n" $needed)"
}

#------------------------------------------------------------------------------
# global_names
# All the names defined in the DEFAULTS file and the stage-?.out files.
#------------------------------------------------------------------------------
global_names() {
    local stage=${1:-$stage}
    local prev
    prev=$((stage - 1))

    # Gather input files
    local files=$normal_defaults
    [[ -n $verbose_mode ]] && files=$all_defaults

    # Gather output files
    local s file
    for s in $(seq 0 $prev); do
        file=$output_dir/stage-$s.out
        [[ -e $file ]] && files="$files $file"
    done

    cat $files 2>/dev/null | sed -n -r "s/^\s*([a-zA-Z_]+)=.*/\1/p" | sort -u
}

#------------------------------------------------------------------------------
# pretty_output
# List names and values of all the globals in DEFAULTS and stage-?.out files
# formated for humans to easily read.
#------------------------------------------------------------------------------
pretty_output() {
    local name value
    for name in $(global_names "$@"); do
        eval value=\"\$$name\"
        # shellcheck disable=SC2059
        printf "$pretty_fmt" "$name" "$value"
    done
}

#==============================================================================
# Outer Utilities
#==============================================================================
#------------------------------------------------------------------------------
# on_exit
# Used in a trap. Make sure we umount the chroot bind mounts and clear the
# window title if it was set.
#------------------------------------------------------------------------------
on_exit() {
    [[ -z $UMOUNT_ERRORS ]] && umount_chroot

    [[ -n $exit_file ]] && rm -f $exit_file

    #kill_children
    clear_pids

    [[ -n $DID_WINDOW_TITLE ]] &&  echo -ne "\e]0;\a"

    et=$((-MAIN_T + EPOCHSECONDS))
    if (( et >= 30 )); then
    #if [[ -n $STAGE_1_T && -n $STAGE_6_T ]]; then
        _end_timer_ MAIN_T "$ME $ARCH $FLAV"
    fi
    #else
    if [[ -r $sign_off_file ]]; then
        SIGN_OFF=$(cat $sign_off_file 2>/dev/null)
        rm -f $sign_off_file
    fi
    _say_ "$SIGN_OFF"
    #fi
}

#------------------------------------------------------------------------------
# clear_pids
# Kill all our background processes. Currently there is only one.
#------------------------------------------------------------------------------
clear_pids() {
    for name in TAIL_PID_1 TAIL_PID_2; do
        eval local pid=\$$name
        unset   $name
        [[ -z $pid ]] && continue
        disown  $pid 2>/dev/null
        kill    $pid 2>/dev/null
    done
}

kill_children() {
    disown $(pgrep -P $$) 2>/dev/null
    pkill -P $$           2>/dev/null
}

#------------------------------------------------------------------------------
# require_programs
# Make sure all these programs are on *root's* path.
#------------------------------------------------------------------------------
require_programs() {
    vsay "Check for required programs: $(pq "$@")"
    local prog missing

    for prog; do
        PATH=$root_path which $prog >/dev/null 2>&1 || missing="$missing $prog"
    done
    [[ -n $missing ]] && error "Missing these required programs: $(pqw $missing)"
}

#==============================================================================
# Template Routines
#==============================================================================
#------------------------------------------------------------------------------
# gather $file-name
# Collect all the lines in files in the Template from "all", from the specific
# flavour and from any -AND- directory contain $FLAV. Sort them and make sure
# they are all unique. Primarily used for creating a package.list. Commented
# lines and lines without a letter or digit are ignored. Trailing comments are
# also ignored.
#------------------------------------------------------------------------------

gather() { _gather_ "$@" | sort -u; }

_gather_() {
    local file=$1.list

    for dir in $(flav_dirs); do
        [[ -r $dir/$file ]] || continue
        sed '/^\s*#/d; s/\s*#.*//' $dir/$file | grep '[a-zA-Z0-9]'
    done
}

gather_cnt() { gather "$@" | wc -l ;}

gather_any() {
    (( $(gather_cnt "$@") >= 1 ))
    return $?
}

gather_say() {
    local file=$1 msg=$2 cnt
    cnt=$(gather_cnt $file)
    psay $cnt "$msg"
}

#------------------------------------------------------------------------------
# gather_join file-name
# Just like gather() but we output a single line with comma separators.
#------------------------------------------------------------------------------
gather_join() {
    local out f
    for f in $(gather $1); do
        out=$out,$f
    done
    echo ${out#,}
}

flav_dirs() {
    local dir=${1:-$template} respin=${2:-$ISO_RESPIN_OF} flav=${3:-$FLAV}

    echo -n $dir/COMMON $dir/$respin-AND-* $dir/*-AND-$respin
    echo " " $dir/*-AND-$respin-AND-* $dir/$flav
}

flavour_list() {
    find "$template" -maxdepth 1 -type d -name '[a-z0-9_]*' -printf '%f\n'
}

#------------------------------------------------------------------------------
# compile_pkg_list package-list exclude-list
#
# Take package-list and remove exclude-list from it
#------------------------------------------------------------------------------
compile_pkg_list() {
    local pkg_list exclude_list result
    pkg_list=$(gather $1)
    exclude_list=$(gather $2)
    for i in $pkg_list ; do
        [[ ! $exclude_list =~ .*$i.* ]] && result="$result $i"
    done
    echo $result
}

#------------------------------------------------------------------------------
# get_template_file [-e] file-name var-name
#
# Fill the variable var-name with the full path to a file in the Template named
# file-name. The priority is first from $FLAV/ then $RESPIN_INHERIT/ and then
# COMMON/. If -e is given then we error out if the file was not found,
# otherwise we leave the variable untouched.
#------------------------------------------------------------------------------
get_template_file() {
    local do_error
    [[ $1 == "-e" ]] && do_error=true && shift

    local flav full file=$1 var=$2

    for flav in $FLAV $RESPIN_INHERIT COMMON; do
        full=$template/$flav/$file
        [[ -r $full ]] || continue
        eval $var=\$full
        return 0
    done

    [[ -n $do_error ]] || return 1
    error "Could not find appropriate $(pqw $name) file in the template"
}

#------------------------------------------------------------------------------
# copy_template_dir [-u] from_dir to_dir
# Copy Template/COMMON/from_dir/* to to_dir/ and then
# copy Template/$FLAV/from_dir/* to to_dir/
# Option -u means copy as normal user.
#
# Option -o means only copy if the original file already exists
#------------------------------------------------------------------------------
copy_template_dir() {
    local sudo=$SUDO  only_overwrite
    [[ $1 == "-u" ]] && sudo="" && shift ;
    [[ $1 == "-o" ]] && only_overwrite=true && shift ;
    local from=$1 dest=$2
    [[ -z $from || -z $dest ]] \
        && fatal "Missing or empty args for copy_template_dir($from, $dest)"

    echo "$dest" | grep -q "^$remaster_dir/work/" \
        || fatal "Suspicious destination in copy_template_dir: $dest"

    $sudo mkdir -p $dest
    for flav in COMMON $RESPIN_INHERIT $FLAV; do
        local dir=$template/$flav/$from
        [[ -d $dir ]] || continue
        if [[ -n $only_overwrite ]]; then
            say "Only overwrite from Template: $(pq $flav/$from)"
            only_overwrite $dir $dest
        else
        	#ensure template files are read-only on group permission
        	chmod -R g-w $dir/
            say "Copy from Template: $(pq $flav/$from)"
            $sudo cp -R --preserve=link,mode $dir/* $dest/
        fi
    done
}

only_overwrite() {
    local from_dir=$1  dest_dir=$2  from  dest
    while read -r from; do
        dest=$dest_dir${from#"$from_dir"}
        [[ -f $dest ]] || continue
        echo "  --> ${dest#"$dest_dir"}"
        $sudo cp -d $from $dest
    done<<Only_Overwrite
$(find $from_dir -type f -o -type l)
Only_Overwrite
}

update_add_remove_lists() {
    local flav dir fname file pkgs date
    date=$(printf '%(%e %B, %Y)T' -1)

    for flav in $(flavour_list); do
        dir=$template/$flav
        [[ -d $dir ]] || continue
        for fname in remove.list add.list; do
            file=$dir/$fname
            [[ -e $file ]] || continue
            pkgs=$(grep -v -e "^\s*#" -e "^\s*$" $file | sed 's/\s*#.*//')
            [[ -n $pkgs ]] || next
            cnt=$(echo "$pkgs" | wc -l)
            say "Found $(pqn $cnt) packages in $flav/$fname"
            say_in $high_co "$pkgs"
            #say "$(echo "$pkgs" | sed -e "s/^/    $high_co/" -e "s/$/$nc/")"

            case $fname in
                remove.list)  update_remove_list $file $flav "$pkgs";;
                   add.list)  update_add_list    $file $flav "$pkgs";;
                          *)  error
            esac
            if YES_no "Delete file $(pq $flav/$fname)"; then
                rm -f $file
            fi
        done
    done
    return 0
}


update_remove_list() {
    local targ_dirs file=$1 flav=$2 pkgs=$3

    local comment="#-- REMOVE ($date)"
    if [[ $flav =~ [A-Z] ]]; then
        targ_dirs=$template/$flav
        [[ $flav != "COMMON" ]] && targ_dirs="$targ_dirs $template/COMMON"
    else
        targ_dirs=$(flav_dirs $template $flav $flav)
    fi

    local p tdir tfile tflav short preg regex
    for tdir in $targ_dirs; do
        for tname in package basic-package pesky-packages; do
            tfile=$tdir/$tname.list
            tflav=$(basename $tdir)
            short=$tflav/$tname.list
            [[ -e $tfile ]] || continue
            for p in $pkgs; do
                preg=${p//+/\\+}
                regex="^\s*$preg\s*\\(#\|$\)"
                grep -q "$regex" $tfile || continue
                if YES_no "Remove package $(pq $p) from $short"; then
                    sed -n "/$regex/ s/^\s*\($preg\)\>.*/$comment \1/p" $tfile
                    sed -i "/$regex/ s/^\s*\($preg\)\>.*/$comment \1/"  $tfile
                fi
            done
        done
    done
}

update_add_list() {
    local p targ_dirs  file=$1  flav=$2  pkgs=$3 tfile comment short
    tfile=$(dirname $file)/package.list
    comment="#-- ADD ($date)"
    short=$flav/package.list
    for p in $pkgs; do
        local line
        line=$(printf "%-30s $comment" $p)
        if YES_no "Add package $(pq $p) to $short"; then
            echo "$line"
            echo "$line" >> $tfile
        fi
    done
}

md5sum_file() {
    local dir file
    dir=$(dirname $1)
    file=$(basename $1)
    (cd $dir && md5sum $file > $file.md5)
}

sha256sum_file() {
    local dir file
    dir=$(dirname $1)
    file=$(basename $1)
    (cd $dir && sha256sum $file > $file.sha256)
}

zsyncmake_file() {
    local dir file
    dir=$(dirname $1)
    file=$(basename $1)
    (cd $dir && zsyncmake -e $file)
}

#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------
make_real() {
    local file=$1
    [[ -L $file ]] || return
    local dest
    dest=$(readlink -f $file)
    [[ -f "$dest" ]] || return
    say "Convert symlink $file to a real file"
    local tmp
    tmp=$(mktemp $file.XXXXXXXX)
    cp $dest $tmp
    mv $tmp $file
}

#------------------------------------------------------------------------------
# Is this an antiX iso?
#------------------------------------------------------------------------------
is_antiX() { [[ $DISTRO_NAME = "antiX" ]] ; return $? ; }

#------------------------------------------------------------------------------
# Distro based check of flavour name
#------------------------------------------------------------------------------
is_distro_flav() {
    local flav=$1
    if is_antiX; then
        case $flav in
            base|core|full) return 0 ;;
        esac
        return 1
    fi
    #
    return 0

    #case $flav in
    #     mx32|mx64|mxahs|mxkde|mxbase64|mxbase32|mxflux32|mxflux64|mxworkbench32|mxworkbench64) return 0 ;;
    #esac
    #return 1
}

#==============================================================================
# One off routines to update the template due to name changes, etc
#==============================================================================
#------------------------------------------------------------------------------
# update_template old-directory new-directory
# Moves old-directory to new-directory in Template after prompting.
#------------------------------------------------------------------------------
update_template() {
    local old=Template/$1 new=Template/$2
    local full_old=$script_dir/$old full_new=$script_dir/$new
    [[ -d $full_old ]] || return
    [[ -d $full_new ]] && return
    echo "Update Template"
    YES_no_loud "Rename $(pq $old) to $(pq $new)" || vexit "Must update to continue"
    mv $full_old $full_new
}

update_template_file() {
    local old=$1 new=$2
    for dir in Template/*; do
        [[ -d $dir ]] || continue
        [[ -e $dir/$new ]] && continue
        [[ -e $dir/$old ]] || continue
        say "Moving $(pq $old) to $(pq $new) in Template/$(basename $dir)"
        mv $dir/$old $dir/$new
    done
}

update_list_names() {
    local list
    list=$(find Template -name "*-list")
    [[ -n $list ]] || return;
    echo "Rename *-list file names to *.list"

    YES_no_loud "Rename these files?" || vexit "Must update to continue"

    for old in $list; do
        new=${old/-list/.list}
        [[ -n $new ]] || continue
        echo "Renaming $old"
        mv "$old" "$new"
    done
}

main "$@"

my_exit 0
